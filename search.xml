<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[经济的增长和衰退就像是悠悠球一样来回摆动]]></title>
    <url>%2F2019%2F06%2F30%2Feco-boom-and-bust%2F</url>
    <content type="text"><![CDATA[1. Boom and bust商业周期是在经济增长（boom）和经济衰退（bust）或停滞（stagnation）之间来回转换的。西斯蒙第（Jean-Charles Sismondi） 第一个认知到经济危机周期的存在，而后法国人 迪努瓦耶Charles Dunoyer 揭示了周期的形式。 西斯蒙第挑战了相信市场机制可以快速实现供需均衡并提供就业的斯密等人，认为供需平衡最终会实现，但是一定是要经过“很多可怕的痛苦的”过程。在他的著作《政治经济学新原理》（New Principles of Political Economy, 1819）发表前，很多经济学家都忽视了经济的周期繁荣和衰退，并通常归结为战争等外部原因。在西斯蒙第的理论中，经济变动是市场生产过剩和消费低迷的的结果，而这种结果又是繁荣时期的发展不平衡所带来的_。西斯蒙第在自由政策和国家干预中站在 _国家干预 一方，认为国家对财富的管控才能避免经济周期的危机。 2. Fuelling the boom经济的增长和衰退就像是悠悠球一样来回摆动：==yo-yo，图片来自cdn4.iconfinder.com==经济发展使商业繁荣，工人的薪水增加，可以购买更多的商品，为经济增常提供燃料动力（fuelling）。商品销售量上升，公司规模随之扩大，新的员工加入，消费水平持续上升。与此同时，企业间的竞争加大，公司通过过度生产来赚取利润，直到供过于求的情况出现。此时他们不得不降低价格，减少利润，面临裁员，进入到衰退的阶段。而当价格降到足够低，可以刺激需求的时候，这个悠悠球就又开始摆动起来了。1825年的恐慌（Panic of 1825）印证了经济周期的存在，当时的股票崩盘是第一个可追溯的因为内部经济事件所导致的危机，它促成了英国六家伦敦银行和六十家国家银行的关闭，其萌芽源自一个不可思议的投机性投资骗局——_波亚斯（Poyias）_。波亚斯是由麦格雷戈尔 _虚构的国家_，那里土地肥沃，玉米一年三熟；河水澄澈纯净，河床下遍布黄金，好似一个世外桃源。书写的真实是一回事，但是会营销懂金融的骗子才是真正厉害的骗子(con man)。麦格雷戈尔举办宴会，邀请伦敦各界名流出入，和现在请明星代言差不多。而后他设计了波亚斯国家的货币，售卖并不存在的波亚斯国家的土地，同时向英国民众发行国债，鼓励英国人将英镑兑换成波亚斯币，在债券市场上骗得130万英镑，相当于现在36亿英镑。后来骗局被揭穿，麦格雷戈尔入狱，但是“波亚斯”产生的经济动荡余波（repercussions）已经无法挽回。==A Bank of Poyais “dollar”，图片来自维基== 3. Early trade protection15世纪到17世纪中叶是重商主义的重要发展时期，虽然在中间有重农学派的影响，但直至18世纪，重商主义在欧洲大陆仍占有重要地位。在英国产业革命的迅速发展中，运用了重商主义思想的 《谷物法》（Corn Laws, 1815） 问题曾成为当时重要的经济和政治问题。在拿破仑战争期间，从欧洲大陆进口小麦是十分困难的，所以英国的小麦价格飙升，很多地主都增加了种植小麦土地的比例。然而，从经济周期来看，小麦的大量生产会使价格降低。这时，在国会中有控制权的地主通过《谷物法》，规定谷物价格在一夸特低于80先令的时候，禁止国外谷物进口，以维持国内谷物高价。这确实保护了农民和地主，但小麦价格超出了穷人可以支付的范围，工业资产阶级和农业资产阶级的斗争日益激烈。==A meeting of the Anti-Corn Law League in Exeter Hall in 1846，图片来自维基==李嘉图就生于这个时代，他认为保护政策在长期的流通中会限制国家增加财富的能力。同时，他对《谷物法》持有反对意见，声称这些法律会使英国变得更穷，并发展出一种理论，这种理论已经成为所有希望为自由贸易辩护的人的主要支柱，我们将在明天的内容中学习这个理论。 4. David Ricardo==David Ricardo，图片来自维基==李嘉图1772年生于犹太资产阶级家庭，父亲是富有的伦敦交易所经纪人。李嘉图只受过初等教育，在14岁时便和父亲在交易所工作，对金融业务非常熟悉。21岁时，他与教友会教徒Priscilla Wilkinson相恋，宗教信仰的不同使李嘉图和父亲发生矛盾，私奔后独立生活，建立了自己的股票公司。因为他善于钻研和把握时机，在25岁时就相当富有。 5.知识拓展-Bull and bear markets和经济的整体繁荣和衰落一样，市场也会有上升和下降。价格维持上升趋势的市场称为 牛市（bull market）_，而价格下降的被称为 _熊市（bear market）_。这样的市场标签可以运用在股票、债券和购房市场中。牛市经常出现在经济增长时期，投资者对于经济发展持乐观态度并购买股票，提高财产价值。熊市到来，投资者开始像熊一样“看跌”（bearish），抛售财产。==Bull market VS Bear market，图片来自avantfx.com==为什么是牛和熊？关于它们名字来的来源尚不明确，以下是两种最常见的解释：“熊”和“牛”这两个词被认为源于动物攻击其对手的方式。也就是说，公牛会把它的角向上倾斜，而熊会向下滑动。这些行为与市场的变动相关：如果趋势上升，它被认为是牛市; 如果趋势下降，那就是熊市。因为在西方古代文明中，牛代表着力量、财富和希望_，而熊代表着 _抑制狂热、消化自身、见机重生_。古罗马传说中，一头逃走的烈性野牛被杀后，它的肉身化成覆盖大地的植被，它的脊柱化为小麦，它的血管化为藤类植物，它的精子变成各种对人有益的动物。牛牺牲了自身，但使万物获得诞生。因此人们用“牛市”表示对财富的期盼。熊也是古代西方人崇拜的对象。在冬眠期的5个月内，熊可以随时清醒，甚至可以怀孕育崽。当春天来临，熊再返地面。人们用“熊”表示跌市，其深远意义在于：股市的调整是不为人们的意志所左右的（像熊一样不能驯化），这个名字告诉人们要像熊一样，在必要的时候从喧嚣中归隐起来，耐心等待，直到重生机会的来临。 参考文献 Panic of 1825：https://en.wikipedia.org/wiki/Panic_of_1825Poyais：https://en.wikipedia.org/wiki/Gregor_MacGregorDavid Ricardo：https://en.wikipedia.org/wiki/David_Ricardo#Personal_life]]></content>
      <categories>
        <category>Economic</category>
        <category>Boom and bust</category>
      </categories>
      <tags>
        <tag>Economic</tag>
        <tag>Poyias</tag>
        <tag>Ricardo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[市场供求关系的形成]]></title>
    <url>%2F2019%2F06%2F29%2Feco-over-production%2F</url>
    <content type="text"><![CDATA[1 . The impossibility of overproduction斯密在撰写《国富论》时就注意到，商人常常将生意的失败与资金匮乏和生产过剩联系在一起。斯密通过阐述货币在经济中的职能揭穿（debunk）了所谓资金匮乏的真相，而后者则被法国经济学家让·巴提斯特·萨伊（Jean-Baptiste Say）在他的《政治经济学概论》（A Treatise on Political Economy, 1803）中驳回。 萨伊认为，生产过剩是不存在的（over-production is impossible）：一旦商品生产出来就会为其他的商品创造市场。比如，一个裁缝制造和卖出衣服的钱，马上会被用来买面包和啤酒，面包和啤酒就有了市场。萨伊认为人们没有 囤钱（hoard money） 的欲望，因此供应商品的总价值等于需求商品的总价值，这种表述渐渐成为了萨伊定律：供给创造自己的需求（supply creates its own demand），其最重要的观点在于如果供给创造了一个等价值的需求，那么就不会存在生产过剩（over-production）或供过于求（glut）了。==over-production，图片来自cdn-images-1.medium.com==对于企业来说，他们可能会错误地估计需求水平，然后过度生产。但奥地利出生的美国经济学家路德维希·冯·米塞斯Ludwig von Mises认为“笨拙的企业家”（“the bungling entrepreneurs”）很快就会被这个市场驱逐出去，而没有被利用的资源将被重新分配给更有利可图的经济领域。所以生产过剩是不会发生的，因为人的欲望远比我们制造商品的能力大得多。萨伊定律便成为了古典经济学家和凯恩斯主义经济学家矛盾冲突的阵地，前者认为供给侧才是经济增长的主要因素，而后者却只将增长与增加需求挂钩。 2. Why keep money？凯恩斯在他的著作 《就业、利息和货币通论》（The General Theory of Employment, Interest and Money, 1936） 中抨击了萨伊认为所有的钱都花在购买其他商品上的观点，他指出，人们有时可能会出于一些原因将收入存起来，而不是用来买东西。当人们不用这些钱去进行借贷和投资时，货币流通率降低，需求将最终低于生产价值。这时就会进入到 “需求不足”（“demand deficiency”） 的瓶颈，继而出现失业率的升高。生产过剩真如萨伊所说的不可能存在吗？1929年至1933年，美国经历了四年的经济大萧条（the Great Depression），华尔街股票暴跌产生的疯狂挤兑、银行倒闭、工厂关门、工人失业、内战边缘等连锁反应让美国经济一落千丈。农业资本家和大农场主大量销毁“过剩”的产品，小麦和玉米替煤炭做燃料，牛奶倒进密西西比河。为什么？当时美国生产力不断提高，而人们的工资却一直持续低水平，这就导致了美国生产能力十分过剩的现象。由于供给多，人们想买却限制于自己的工资水平，储存能力又不允许，超低价会引发同行的恶意竞争等问题让人们不得不这样做。==In the Great Depression, farm owner poured milk into the Mississippi River，图片来自inews.gtimg.com==当时的失业人口总数达到了830万，在美国各城巿，排队领救济食品的穷人长达几个街区，曾经衣冠楚楚的银行家出现在领取救济面包的队伍中。这样看来，凯恩斯的观点在大萧条时期很有说服力，特别是反驳了萨伊所说的失业只会存在于一些工厂并只持续一小段时间的说法。==Free food for the unemployed，图片来自inews.gtimg.com== 3 . Borrowing or taxation政府花销的资金如何筹集？是通过发放政府债券，还是通过税收呢？英国经济学家大卫·李嘉图（David Ricardo）是第一个详细阐明该问题的人。他在 《政治经济学和赋税原理》（Principles of Political Economy and Taxation, 1817） 表明了自己的观点：债券和税收这两种方式没什么不同。赋税者应该意识到，购买政府债券会导致未来更多的税收，而从另一个角度来看，人们会提前预留储蓄以应付以后要支付的税款。人们了解政府的预算限制，无论其决定征税或发放政府债券，其效果都是相同或等价的。人们会把买债券获得的额外收入存起来，此时人们可支配的财富的数量与征税的情况一样，这就是 李嘉图等价（Ricardian equivalence） 。==Return the extra money，图片来自dn.sohucs.com==想象一下，一个赌博的父亲向两个儿子一人借了100元，并给了他们每人5%的利息，此时两个儿子的额外收入各为5元。但是父亲告诉儿子们，从他们这里借的钱这个月不会动，因为他已经从朋友Alex那里借到了200元钱。成天逍遥自在、傻呵呵的小儿子把5元钱直接花掉了，而机敏一些的大儿子却意识到，下个月父亲还Alex钱的时候肯定还要交利息，到时候还会管他们要。相当于这额外的5元钱还是会被征收回去。 4 . The modern debate美国经济学家巴罗Robert Barro在他1974年发表的文章中，重提了这一想法，着眼于调查人们不顾及税收和政府债券的情况。如果公众是理性预期的，那么不管是债券融资还是税收融资，政府所采用的融资方式并不会影响经济中的消费、投资、产出和利率水平，具有理性预期的公众明白债券变现最终还是要靠增税来完成，即现期债券相当于未来税收，政府债券融资只不过是移动了增税的时间。因为政府和个人的借贷利率不可能相同，所以这种情况不会发生。而且，人的寿命是有限的，消费者具有“利他主义”的遗产动机，尽管发放政府债券具有的减税效应使消费者收入增加，但在理性地预期到将来税收将增加，而子女消费水平将受到不利影响时，消费者就不会因为现期收入的增加而增加消费。消费者不会将政府发行公债融资引起的财政扩张及收入增加看作是幸运的意外收获，他们宁愿将一部分收入储蓄起来以支付未来（甚至子女）的税收负担。巴罗试图通过“李嘉图等价定理”证明财政刺激政策的无效性，激起了整整一代经济学家持续的考察、攻击和验证。1974年那篇论文成为了迄今为止被引用最多的经济学文献之一。==哭泣！为财政刺激买单，图片来自larspsyll.files.wordpress.com== 5 . Government spending李嘉图等价定理有时也被认识为 债务中性（debt neutrality） ，即扩张性的财政政策不会刺激经济扩张，且政府以债券和税收筹资的效果是等价的。这种观点也被新古典经济学家用来反击凯恩斯主义政策：财政支出促进需求和经济增长。他们认为，如果人们知道政府通过财政支出的形式度过萧条，他们的理智会预料到未来更大的税收，所以他们是不会盲目回应的。然而实际证据到底是支持还是反对呢？这一点尚无定论。 6 . Jean-Baptiste Say今天的内容中我们主要介绍了萨伊和李嘉图的思想，因为后面的内容中我们会继续学习李嘉图的理论知识，所以先来了解一下萨伊。==Jean-Baptiste Say，图片来自fee.org==让·巴提斯特·萨伊（Jean-Baptiste Say）出生于一个法国商人家庭，早年开始学习经商，后去英国接受商业教育。在英国他看到了产业革命的发展并接触了斯密的著作。回法国经商的他遇到法国大革命，拥护革命，为革命派撰稿也曾投笔从军。脱离革命后，他完成上文提到的《政治经济学概论》的编写，却因为波旁王朝的复辟，反对关税保护政策被禁，他被迫经商后转为学术研究，撰写了《政治经济学教程》（Complete Course of Practical Political Economy, 1828-1830）。在担任法兰西学院政治经济学教授期间，他把政治经济学思想叙述的通俗而优美。其著作被翻译成多种文字传遍欧洲。很多人是通过萨伊了解斯密和英国古典政治经济学的。但是很多经济学家推崇的“萨伊定律”却受到了马克思的批评，他指出萨伊定律的根本错误在于混同了资本流通与简单商品流通，又把简单商品流通归结为物物交换。货币是可以贮藏的，所以总供给并不等于总需求。 参考文献 Great depression：https://en.wikipedia.org/wiki/Great_DepressionRicardian equivalence：https://en.wikipedia.org/wiki/Ricardian_equivalenceJean-Baptiste Say：https://en.wikipedia.org/wiki/Jean-Baptiste_Say]]></content>
      <categories>
        <category>Economic</category>
        <category>Over Production</category>
      </categories>
      <tags>
        <tag>Economic</tag>
        <tag>Overproduction</tag>
        <tag>Borrowing</tag>
        <tag>Taxation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux 常用命令]]></title>
    <url>%2F2019%2F06%2F29%2Ftmux%2F</url>
    <content type="text"><![CDATA[简介tmux被称为terminal complexer,作用就是在一个窗口下可以打开多个窗口和切分窗口(叫做panes).层次为3级,从高到低位:session,window和pane. 作用tmux允许我们在ssh不稳定的情况下稳定得运行程序. 简单的命令session-level12345tmux ls # list sessions tmux new -s SESSION_NAME # 创建新的session tmux attach -t SESSION_NAME # 连接session tmux detach # 从session断开 tmux rename-session -t OLD_NAME NEW_NAME window-level123456tmux new-window (prefix + c) # prefix指的是Control+b同时按下后释放,prefix +c意味着Control+b同时按下后释放然后按c tmux select-window WINDOW_NAME (prefix + WINDOW_NUM) # 切换窗口, window_number为1-9的数字 tmux rename-window (prefix + ,) # 重命名窗口 tmux kill-window -t WINDOW_NAME (prefix + *) # 关闭窗口 ``` ## pane-level tmux split-window (prefix + “) # 把当前window分成上下两个panestmux split-window -h (prefix + %) # 把当前window分成左右两个panestmux swap-pane -[UDLR] (prefix + ) # navigate panestmux kill-pane (prefix + x) # kill pane]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scp 用法]]></title>
    <url>%2F2019%2F06%2F28%2Fscp%2F</url>
    <content type="text"><![CDATA[作用linux远程拷贝工具 用法scp [-option] source dest 远程连接时文件地址写法USER@PATH:FILEPATH option r,文件夹]]></content>
      <tags>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supervisor 介绍]]></title>
    <url>%2F2019%2F06%2F23%2Fsupervisor%2F</url>
    <content type="text"><![CDATA[supervisor是一个进程管理工具,用来启动,停止,重启和监测进程.可以实现诸如检测某个进程,一旦其被杀死就重启的功能. 参考https://www.jianshu.com/p/03619bf7d7f5 安装 sudo pip install supervisor 通过echo_supervisord_conf 命令生成配置文件 echo_supervisord_conf &gt; /etc/supervisord.conf 配置文件加入program配置文件的地址12[include] files = /etc/supervisor/*.conf 创建program配置文件注意把program配置文件放在配置文件中files项下 123456789101112131415161718;a_server.conf[program:a_server] ;程序名 directory = /root/amazon_server ; 程序的启动目录 command = python app.py ; 启动命令，可以看出与手动在命令行启动的命令是一样的 autostart = true ; 在 supervisord 启动的时候也自动启动 startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了 autorestart = true ; 程序异常退出后自动重启 startretries = 3 ; 启动失败自动重试次数，默认是 3 user = root ; 用哪个用户启动 redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 false stdout_logfile_maxbytes = 100MB ; stdout 日志文件大小，默认 50MB stdout_logfile_backups = 10 ; stdout 日志文件备份数 ; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件） stdout_logfile = /root/amazon_server/app.log killasgroup=true # 使用uwsgi时需要加上stopasgroup=true # 使用uwsgi时需要加上 读取配置 supervisord -c /etc/supervisord.conf 断开现在的配置 unlink /***/supervisor.sock supervisorctlsupervisorctl是supervisord的命令行客户端管理工具，用来管理进程 supervisorctl # 进入交互shell环境reread #读取配置文件start a_server #启动程序status # 查看进程状态exit # 退出 开启多个supervisor可以通过不同的配置文件来开启多个supervisor,连接方式为 supervisorctl -c 配置文件 注意更新已有文件时需要先stop,然后reread;避免使用reload,因为reload会重启所有服务]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nohup 用法]]></title>
    <url>%2F2019%2F06%2F23%2Fnohup%2F</url>
    <content type="text"><![CDATA[作用linux下用来在后台执行程序 指令nohup CMD &lt; INPUT &gt; STDOUT 2&gt; STDERR 举例nohup ./xixi.sh &gt; /dev/null 2&gt;&amp;1 &amp; # /dev/null表示输出到外太空 查看后台运行的程序ps -aux # a表示all, u表示按照user, x表示不以终端机来区分]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 锁简介]]></title>
    <url>%2F2019%2F06%2F23%2Fmysql%2F</url>
    <content type="text"><![CDATA[mysql的锁机制数据库使用中,除了传统的计算资源(CPU,RAM),不同用户也会共享数据.锁机制就是为了协调多个用户或多个进程/线程并发访问数据,保证数据并发访问的一致性和有效性.每个事务,都可以添加对涉及到的数据的锁. 按照封锁类型分类,分为排他锁(又叫写锁或X锁)和分享锁(读锁或S锁). 排他锁,阻止其它事务对锁作用的数据的读和写; 分享锁,阻止其它事务对锁作用的数据的写. 按照锁作用的数据的粒度,分为行锁,表锁和页锁.其中页锁比较罕见.1.行锁就是对记录上锁,这是最小的粒度,占用资源最多,允许的并发也最大.试想,你锁了两行数据,其他人还可以对同表的其他行数据操作,但你和其他人可能对这张表上了好几个锁;2.表锁是对数据表上锁,这是最大的粒度,占用资源最少 join相关left join： 以左表为主体,基于链接条件补充右表的列right join: 以右表为主体,基于链接条件补充坐表的列inner join: 基于链接条件给出左右表的列inner full join: left join 和 right join的union 例子A表| id | name|| 1 | a || 2 | beta | B表| id | name|| 1 | a || 2 | b | A left join B on A.name=B.name 为| A.id | A.name | B.id | B.name || 1 | a | 1 | a || 2 | beta | null | null | A right join B on A.name=B.name 为| A.id | A.name | B.id | B.name || 1 | a | 1 | a || null | null | 2 | b | A inner join B on A.name=B.name 为| A.id | A.name | B.id | B.name || 1 | a | 1 | a | A full outer join B on A.name=B.name 为| A.id | A.name | B.id | B.name || 1 | a | 1 | a || 2 | beta | null | null || null | null | 2 | b | @@var: 局部变量@@var: 全局变量 应用举例分组后按照某个指标选择每组前几名按照省来分组,以gdp为指标,选取每个省gdp前十的城市SELECT province, city, gdp, GDP_rank FROM ( SELECT province, city, gdp, @GDP_rank := IF(@current_province = province, @GDP_rank + 1, 1) AS GDP_rank, @current_province := province FROM GDP JOIN (SELECT @current_province := NULL, @GDP_rank := 0) AS vars ORDER BY province, GDP DESC, city ) ranked WHERE GDP_rank &lt;= 10; 其中GDP JOIN (SELECT @current_province := NULL, @GDP_rank := 0) AS vars是为了初始化current_province和GDP_rank两个局部变量]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git之tag]]></title>
    <url>%2F2019%2F06%2F23%2Fgit-tag%2F</url>
    <content type="text"><![CDATA[作用gitlab/github的tag用来静态得标记版本.比如在branch v0.1开发时,到了某次commit时(比如当前可以作为上线的版本),为了标记当前状态,设置tag v0.1.1. 使用方法打标签git tag -a 0.1.1 -m “Release version 0.1.1” 提交到远程服务器git push origin –tag # 全部tagsgit push origin v0.1.1 # 单个tag 从远程fetch所有taggit fetch –tags reset to某个taggit checkout -b [newBranch] v0.1.1 # 需要创建新分支,因为tag只是一个快照 删除远程taggit push origin :refs/tags/v0.1.1 删除本地taggit tag -d v0.1.1 查看本地所有tagsgit tag 查看某个taggit show v0.1.1 给指定的commit打taggit tag v0.1.1 5ad71e11]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka 简介]]></title>
    <url>%2F2019%2F06%2F23%2Fkafka%2F</url>
    <content type="text"><![CDATA[kafka简介kafka是一个实时的分布式的发布-订阅消息系统和数据处理工具.相比传统的消息系统,比如ActiveMQ和RabbitMQ,kafka是分布式的,具有高扩展(分布式天然高扩展),高吞吐量,高可用和贼鸡儿快的特性. 消息和生产/消费消息系统中,消息指的是不同系统之间的通过http,scp等方式传递的数据流.消息有两端,生产端和消费端,两端的主题分别叫生产者和消费者.生产速度比消费速度快很多,会造成消息阻塞,最终系统延时;消费端宕机,则消息丢失. 消息中间件(Message Broker)为了避免系统延时和宕机的问题,中间件应运而生,用来解耦消息生产和消息消费.中间件本质上是个持久化储存消息的媒介(存在磁盘),作为消息的集散中心.即使消费者来不及消费,消息也不会丢失.Kafka集群包含一个或多个服务器,这种服务器就叫中间件. TopicTopic是kafka中数据的基本单元.kafka中生产者发布带有topic的消息,发给中间件.每个队列对应一个topic.消费者订阅topic,获得对应的消息队列.这样每个消费者对应的消息队列中就只包含自己想要的.每个消费者对应一个offset来记录当前消费的消息位置.即使发生系统宕机,重新恢复后也可以从offset处重新开始. Parition和ReplicaPartition是物理上的概念,每个topic分多个分区(partition),分区的编号从0开始.每个分区都有副本(replica),保证partition的高可用性,副本的数量是可以设置的. Broker集群为了提高可用性和速度,kafka使用中间件集群.分区的副本存在不同的中间价中,每个分区都有一个leader和一个或多个follower. leader负责提供读写服务(生产者和消费者只和leader交互), follower同步leader数据(也有说消费者可以在follower中进行查询,不确定). leader坏了就用follower. 参考http://blog.hszofficial.site/experiment/2019/04/06/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ https://www.bilibili.com/video/av37714232/?p=2 https://zhuanlan.zhihu.com/p/37405836]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Kafka</tag>
        <tag>Producer</tag>
        <tag>Consumer</tag>
        <tag>Broker</tag>
        <tag>Topic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crontab 使用简介]]></title>
    <url>%2F2019%2F06%2F23%2Fcrontab%2F</url>
    <content type="text"><![CDATA[简介cron是一个linux下 的定时执行工具，可以在无需人工干预的情况下运行作业 /sbin/service crond start //启动服务 /sbin/service crond stop //关闭服务 /sbin/service crond restart //重启服务 /sbin/service crond reload //重新载入配置 /sbin/service crond status //查看服务状态 写法minute hour day-of-month month-of-year day-of-week who command 举例12,24 12 * * * root haha.sh # 以root身份每天12点12分和24分执行haha.sh/2 * * * * * root haha.sh # 每两分钟执行haha.sh 命令crontab -e # 进入用户.cron文件来编辑crontab -l [-u USER] # 查看用户(默认为当前用户)的文件 经典错误premature EOF -&gt; 末尾加一空白行 注意crontab xxx.cron # 这条命令会覆盖当前用户的cron文件,不要随便使用]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Crontab</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 全面介绍]]></title>
    <url>%2F2019%2F04%2F10%2Fnpm%2F</url>
    <content type="text"><![CDATA[什么是 NPMnpm 之于 Node.js ，就像 pip 之于 Python， gem 之于 Ruby， pear 之于 PHP 。 npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。 为什么要使用 NPMnpm 是随同 Node.js 一起安装的包管理工具，能解决 Node.js 代码部署上的很多问题，常见的场景有以下几种： 允许用户从 npm 服务器下载别人编写的第三方包到本地使用。 允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。 npm 的背后，是基于 couchdb 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。 如何使用 NPM安装npm 不需要单独安装。在安装 Node 的时候，会连带一起安装 npm 。但是，Node 附带的 npm 可能不是最新版本，最后用下面的命令，更新到最新版本。 1$ sudo npm install npm@latest -g 如果是 Window 系统使用以下命令即可： 1npm install npm -g 也就是使用 npm 安装自己。之所以可以这样，是因为 npm 本身与 Node 的其他模块没有区别。 然后，运行下面的命令，查看各种信息。 1234567891011# 查看 npm 命令列表$ npm help# 查看各个命令的简单用法$ npm -l# 查看 npm 的版本$ npm -v# 查看 npm 的配置$ npm config list -l 使用npm initnpm init 用来初始化生成一个新的 package.json 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。如果使用了 -f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的 package.json 文件。 1$ npm init -y npm setnpm set 用来设置环境变量 1234$ npm set init-author-name 'Your name'$ npm set init-author-email 'Your email'$ npm set init-author-url 'http://yourdomain.com'$ npm set init-license 'MIT' 上面命令等于为 npm init 设置了默认值，以后执行 npm init 的时候，package.json 的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。 npm infonpm info 命令可以查看每个模块的具体信息。比如，查看 underscore 模块的信息。 1$ npm info underscore 上面命令返回一个 JavaScript 对象，包含了 underscore 模块的详细信息。这个对象的每个成员，都可以直接从 info 命令查询。 12345$ npm info underscore description$ npm info underscore homepage$ npm info underscore version npm searchnpm search 命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式。 1$ npm search &lt;搜索词&gt; npm listnpm list 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。 1234567$ npm list# 加上 global 参数，会列出全局安装的模块$ npm list -global# npm list 命令也可以列出单个模块$ npm list underscore npm install使用 npm 安装包的命令格式为：npm [install/i] [package_name] 本地模式和全局模式npm 在默认情况下会从 http://npmjs.org 搜索或下载包，将包安装到当前目录的 node_modules 子目录下。如果你熟悉 Ruby 的 gem 或者 Python 的 pip，你会发现 npm 与它们的行为不同，gem 或 pip 总是以全局模式安装，使包可以供所有的程序使用，而 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。 我们在使用 supervisor 的时候使用了 npm install -g supervisor 命令，就是以全局模式安装 supervisor 。 这里注意一点的就是，supervisor 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 npm config set prefix &quot;路径&quot; 安装完以后就可以用 supervisor 来启动服务了。supervisor 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 Node.js 。 一般来说，全局安装只适用于工具模块，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为本地模式不会注册 PATH 环境变量。 “本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。 本地模式和全局模式的特点如下： 模式 可通过 require 使用 注册 PATH 本地模式 是 否 全局模式 否 是 123456# 本地安装$ npm install &lt;package name&gt;# 全局安装$ sudo npm install -global &lt;package name&gt;$ sudo npm install -g &lt;package name&gt; npm install 也支持直接输入 Github 代码库地址。 12$ npm install git://github.com/package/path.git$ npm install git://github.com/package/path.git#0.1.0 安装之前，npm install 会先检查，node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过， npm 都要强制重新安装，可以使用 -f 或 –force 参数。 1$ npm install &lt;packageName&gt; --force 安装不同版本install 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 @ 和版本号。 123$ npm install sax@latest$ npm install sax@0.1.1$ npm install sax@"&gt;=0.1.0 &lt;0.2.0" install 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 packages.json 文件的哪一项中。 –save：模块名将被添加到 dependencies，可以简化为参数-S。–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。 12345$ npm install sax --save$ npm install node-tap --save-dev# 或者$ npm install sax -S$ npm install node-tap -D dependencies 依赖这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 markdown-it 这个包，版本是 ^8.1.0 ，代表最小依赖版本是 8.1.0 ，如果这个包有更新，那么当我们使用 npm install 命令的时候，npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。 123"dependencies": &#123; "markdown-it": "^8.1.0"&#125; devDependencies 开发依赖在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载。 1234567891011"devDependencies": &#123; "autoprefixer": "^6.4.0",0", "babel-preset-es2015": "^6.0.0", "babel-preset-stage-2": "^6.0.0", "babel-register": "^6.0.0", "webpack": "^1.13.2", "webpack-dev-middleware": "^1.8.3", "webpack-hot-middleware": "^2.12.2", "webpack-merge": "^0.14.1", "highlightjs": "^9.8.0"&#125; 当你有了一个完整的 package.json 文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 npm install 就可以很方便的下载好这个模块所需要的包。 npm install 默认会安装 dependencies 字段和 devDependencies 字段中的所有模块，如果使用 –production 参数，可以只安装 dependencies 字段的模块。 123$ npm install --production# 或者$ NODE_ENV=production npm install 一旦安装了某个模块，就可以在代码中用 require 命令加载这个模块。 12var backbone = require('backbone')console.log(backbone.VERSION) npm runnpm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。package.json 123456789101112&#123; "name": "myproject", "devDependencies": &#123; "jshint": "latest", "browserify": "latest", "mocha": "latest" &#125;, "scripts": &#123; "lint": "jshint **.js", "test": "mocha test/" &#125;&#125; scripts 脚本顾名思义，就是一些脚本代码，可以通过 npm run script-key 来调用，例如在这个 package.json 的文件夹下使用 npm run dev 就相当于运行了 node build/dev-server.js 这一段代码。使用 scripts 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。npm run 是 npm run-script 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。 123456789// 脚本"scripts": &#123; "dev": "node build/dev-server.js", "build": "node build/build.js", "docs": "node build/docs.js", "build-docs": "npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m 'auto-pages' &amp; git push &amp; git checkout master", "build-publish": "rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push", "lint": "eslint --ext .js,.vue src"&#125; npm run 如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。npm 内置了两个命令简写， npm test 等同于执行 npm run test，npm start 等同于执行 npm run start。 1"build": "npm run build-js &amp;&amp; npm run build-css" 上面的写法是先运行 npm run build-js ，然后再运行 npm run build-css ，两个命令中间用 &amp;&amp; 连接。如果希望两个命令同时平行执行，它们中间可以用 &amp; 连接。 写在 scripts 属性中的命令，也可以在 node_modules/.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。 1234#!/bin/bashcd site/mainbrowserify browser/main.js | uglifyjs -mc &gt; static/bundle.js 假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。 1"build-js": "bin/build.sh" pre- 和 post- 脚本npm run 为每条命令提供了 pre- 和 post- 两个钩子（hook）。以 npm run lint 为例，执行这条命令之前，npm 会先查看有没有定义 prelint 和 postlint 两个钩子，如果有的话，就会先执行 npm run prelint，然后执行 npm run lint，最后执行 npm run postlint。 12345678910111213&#123; "name": "myproject", "devDependencies": &#123; "eslint": "latest" "karma": "latest" &#125;, "scripts": &#123; "lint": "eslint --cache --ext .js --ext .jsx src", "test": "karma start --log-leve=error karma.config.js --single-run=true", "pretest": "npm run lint", "posttest": "echo 'Finished running tests'" &#125;&#125; 上面代码是一个 package.json 文件的例子。如果执行 npm test，会按下面的顺序执行相应的命令。 pretest test posttest 如果执行过程出错，就不会执行排在后面的脚本，即如果 prelint 脚本执行出错，就不会接着执行 lint 和 postlint 脚本。 npm binnpm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。 123# 项目根目录下执行$ npm bin./node_modules/.bin 创建全局链接npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 npm install -g express 安装了 express，这时在工程的目录下运行命令：npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。 创建包包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java、.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。Node.js 的包是一个目录，其中包含了一个 JSON 格式的包说明文件 package.json。严格符合 CommonJS 规范的包应该具备以下特征：。package.json 必须在包的顶层目录下；。二进制文件应该在 bin 目录下；。JavaScript 代码应该在 lib 目录下；。文档应该在 doc 目录下；。单元测试应该在 test 目录下。 Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。 我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 package.json，我们可以创建更复杂，更完善，更符合规范的包用于发布。 Node.js 在调用某个包时，会首先检查包中 packgage.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。 package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段：name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。description: 包的简要说明。version: 符合语义化版本识别规范的版本字符串。keywords: 关键字数组，通常用于搜索。maintainers: 维护者数组，每个元素要包含 name 、email(可选)、web(可选)字段。contributors: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。bugs: 提交 bug 的地址，可以是网址或者电子邮件地址。licenses: 许可证数组，每个元素要包含 type（许可证的名称）和 url（链接到许可证文本的地址）字段。repositories: 仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。 包的发布通过使用 npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个 index.js 作为包的接口,一个简单的包就制作完成了。在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 npm adduser 根据提示完成账号的创建完成后可以使用 npm whoami 检测是否已经取得了账号。接下来,在 package.json 所在目录下运行 npm publish，稍等片刻就可以完成发布了，打开浏览器，访问 http://search.npmjs.org/ 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install neveryumodule 命令来安装它。如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段,然后重新使用 npm publish 命令就行了。如果你对已发布的包不满意，可以使用 npm unpublish 命令来取消发布。 *需要说明的是：json 文件不能有注释* 参考链接http://javascript.ruanyifeng.com/nodejs/npm.html 常用命令npm version 查看npm和node的版本npm list –depth=0 [-g] 查看[全局]安装的包npm root [-g] 查看[全局的]包的安装路径]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 学习总结]]></title>
    <url>%2F2018%2F10%2F07%2Fgit%2F</url>
    <content type="text"><![CDATA[git 简介git 是分布式的，所以其核心就是分支，分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到 master 分支，master 分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。在 git 中，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。 实用指令详解merge通常，合并分支时，如果可能，Git 会用 Fast froward 模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用 Fast forward 模式，Git 就会在 merge 时生成一个新的 commit ，这样，从分支历史上就可以看出分支信息。git merge --no-ff -m &#39;merge with no-ff&#39; dev因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。 合并分支时，加上 --no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。 fetch一旦远程主机的版本库有了更新(git 术语叫做 commit)，需要将这些更新取回本地，这时就要用到 git fetch 命令。git fetch &lt;远程主机名&gt;上面命令将某个远程主机的更新，全部取回本地。默认情况下，git fetch 取回所有分支(branch)的更新。如果只想取回特定分支的更新，可以指定分支名。git fetch &lt;远程主机名&gt; &lt;分支名&gt;比如，取回 origin 主机的 master 分支git fetch origin master所取回的更新，在本地主机上要用“远程主机名/分支名”的形式读取。比如 origin 主机的 master，就要用 origin/master 读取。 git fetch -p ：取回远程更新，删除不存在的分支。 pullgit pull 命令的作用是，取回远程主机的某个分支的更新，再与本地的指定分支合并，完整格式如下：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。git pull origin next:master如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git pull origin master上面的命令表示，取回 origin/master 分支，再与当前分支合并。实质上，这等同于先做 git fetch，再 merge。 12git fetch origingit merge origin/master 在某些场合，git 会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在 git clone 的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的 master 分支自动“追踪” origin/master 分支。git 也允许手动建立追踪关系。git branch --set-upstream master origin/next上面的命令指定 master 分支追踪 origin/next 分支。如果当前分支与远程分支存在追踪关系，git pull 就可以省略远程分支名。git pull origin上面命令表示，本地的当前分支自动与对应的 origin 主机“追踪分支”(remote-tracking branch)进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以忽略。git pull上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用 rebase 模式，可以使用 -rebase 选项。git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; pushgit push 命令用于将本地分支的更新，推送到远程主机。它的格式与 git pull 命令相仿。git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;如果省略远程分支名，则表示将本地分支推送与之存在“追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。git push origin master上面命令表示，将本地的 master 分支推送到 origin 主机的 master 分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。git push origin :master等同于git push origin --delete master上面命令表示删除 origin 主机的 master 分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。git push origin上面命令表示，将当前分支推送到 origin 主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。git push如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用 git push 。git push -u origin master上面的命令将本地 master 分支推送到 origin 主机，同时指定 origin 为默认主机，后面就可以不加任何参数使用 git push 了。不带任何参数的 git push ，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。git 2.0 版本之前，默认采用 matching 方式，现在改为默认采用 simple 方式，如果要修改这个设置，可以采用 git config 命令。git config --global push.default matching或者git config --global push.default simple还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 -all 选项。git push --all origin上面命令表示，将所有本地分支都推送到 origin 主机。如果远程主机的版本比本地版本更新，推送时 git 会报错，要求先在本地做 git pull 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 -force 选项。git push --force origin上面命令使用-force选项，结果导致在远程主机产生一个“非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用 -force 选项。最后，git push 不会推送标签(tag)，除非使用 -tags 选项。git push origin --tags loggit log 命令可以查看历史记录，git log 命令显示从最近到最远的提交日志；如果嫌输出信息太多，看得眼花缭乱的，可以试试 git log --pretty=oneline 。我们可以看到当前版本以及之前的版本日志以及版本号。用 git log --graph 命令可以看到分支合并图。或者两个参数一起用：git log --graph --pretty=onelinegit log --graph --pretty=oneline --abbrev-commit首先，git 必须知道当前版本是哪个版本，在 git 中，用 HEAD 表示当前版本，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ， 当然往上100个版本写100个 ^ 比较容易数不过来，所以写成 HEAD~100 。现在，我们要把当前版本回退到上一个版本，就可以使用 git reset 命令：git reset --hard HEAD^当你回退到了某个版本后，git log 只能显示此版本及之前的版本的日志，之后的版本日志就看不到了，但是，我们想恢复到之后教新的版本怎么办？Git 提供了一个命令 git reflog 用来记录你的每一次命令 tag查看标签（用来标记标志性的稳定版本信息）发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。相比于 commit 的版本号(40位16进制)，标签号则要好使的多。所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑定在一起。 git tag [tag name]如果没有标签名，则为查看所有标签，带标签名则为新建标签 git tag &lt;tag name&gt; 就可以打一个新标签 还可以创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字。git tag -a &lt;tag name&gt; -m &lt;comment&gt; ：添加带注释的标签eg: git tag -a v1.2 -m &#39;version 1.2 released&#39; git tag -a &lt;tag name&gt; &lt;md5&gt; ：对某个版本打标签默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的 commit id，然后打上就可以了。git log --pretty=oneline --abbrev-commit比方说要对 add merge 这次提交打标签，它对应的 commit id 是 6224937，那么我们就可以使用命令：git tag v1.2 6224937再用命令 git log 查看标签 可以用 git show &lt;tagname&gt; 查看标签信息 如果标签打错了，也可以删除：git tag -d v1.2 如果要推送某个标签到远程，使用命令 git push origin &lt;tagname&gt;eg: git push origin v1.2 如果标签已经推送到远程，要删除远程标签就要麻烦一点，先从本地删除：git tag -d v1.2然后，从远程删除；删除命令也是 push ，但是格式如下：git push origin :ref/tags/v1.2 git tag -l &#39;[expression]&#39;查看那符合正则表达式的 stashgit stash备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。git stash pop从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。git stash list显示 Git 栈中内的所有备份，可以利用这个列表来决定从哪个地方恢复。git stash clear : 清空 Git 栈。 使用 git 的时候，我们往往使用 branch 解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码，如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码 commit 提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 bug，那么使用 git stash 就可以将你当前未提交到本地的代码推入到 git 的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 bug，等到修完 bug，提交到服务器上后，再使用 git stash apply 将以前一般的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用 git stash 命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑， git stash list 命令可以将当前的 Git 栈信息打印出来，你只需要将找到对应的版本号，例如使用 git stash apply stash@{1} 就可以将你指定版本号为 stash@{1} 的工作取出来，当你将所有的栈都应用回来的时候，可以使用 git stash clear 来将栈清空。在这里顺便提下 git format-patch -n , n是具体某个数字， 例如 ‘git format-patch -1’ 这时便会根据log生成一个对应的补丁，如果 ‘git format-patch -2’ 那么便会生成 2 个补丁，当然前提是你的 log 上有至少有两个记录。 看过上面的信息，就可以知道使用场合了：当前工作区内容已被修改，但是并未完成。这时 Boss 来了，说前面的分支上面有一个 bug，需要立即修复。可是我又不想提交目前的修改，因为修改没有完成。但是，不提交的话，又没有办法 checkout 到前面的分支。此时用 git stash 就相当于备份了工作区了。然后在 checkout 过去修改，就能够达到保存当前工作区，并及时恢复的作用。 注意这里由于只 stash 了一次所以要使用 pop，具体你存放了多少。 remote查看远程仓库名 git remote -v查看远程仓库url git remote add &lt;basename&gt; &lt;url&gt;新增远程仓库 git remote show &lt;basename&gt;查看远程仓库详细信息 git remote rename &lt;old basename&gt; &lt;new basename&gt;重命名远程仓库 commitgit commit -a -m &#39;xx&#39;暂存并提交 branchgit branch查看本地仓库分支 git branch -r查看远程分支情况 git branch -a查看本地和远程的所有分支情况 git branch -v查看本地仓库分支最后一次提交情况 git branch -vv查看分支跟踪情况 git branch &lt;branch name&gt;新建分支 git branch -d &lt;branch name&gt;删除分支 git branch -D &lt;branch name&gt;强制删除分支 git branch [--merged | --no-merged]查看已合并|未合并的本地仓库分支 git branch -u &lt;remote base&gt;/&lt;remote branch&gt;修改当前跟踪分支 checkoutgit checkout -- [file] ：恢复文件git checkout -- demo.html 意思就是，把 demo.html 文件在工作区的修改全部撤销，这里有两种情况：一种是 demo.html 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是 demo.html 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加暂存区后的状态。总之，就是让这个文件回到最后一次 git commit 或 git add 时的状态。 但是如果 git add 到暂存区了，在 commit 之前，想撤销：Git 同样告诉我们，用命令 git reset HEAD file 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区，当我们用 HEAD 时，表示最新的版本。再用 git status 查看一下，现在暂存区是干净的，工作区有修改：还记得如果丢弃工作区的修改吗？对的，使用：git checkout -- demo.html git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。 git checkout -b [branchname] [tagname]在特定的版本上创建一个新的分支并切换到此分支 git checkout -b [local branch] [remote base]/[remote branch]将远程分支检出到本地分支，并追踪 git checkout --track &lt;remote base&gt;/&lt;remote branch&gt;让当前分支跟踪远程分支 rebasegit rebase [basebranch]变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 常见问题git clonegit clone 支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等。使用 https 除了速度慢意外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。 git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;如果不写本地目录名，默认就是版本库的名字 如何新建分支本地建立 branch 並立即切换到新分支git checkout -b &lt;branch_name&gt; 下面的命令表示，在 origin/master 的基础上，创建一个分支。git checkout -b newBranch origin/master 修改分支名称git branch -m &lt;new_name&gt; 从远程仓库拉取代码到本地仓库，并建立跟踪关系git checkout -b &lt;本地新分支名&gt; &lt;对应的远程分支名&gt; 如何在远程仓库新建一个分支新建一个本地分支，按照正常流程提交完代码后，推送到远程git push &lt;remote base&gt; &lt;local branch&gt;:&lt;remote branch&gt; 比较文件git diff HEAD -- demo.html命令可以查看工作区的 demo.html 和版本库里面最新版本的区别。 忽略某些文件默认方法是在当前项目目录下创建一个 .gitignore 文件，如果需要忽略的文件已经添加到版本库中，请先移除git rm --cached [file]不删除文件，只移除追踪。 123cat .gitignore*.[oa]*~ 文件 .gitignore 的格式规范如下： 所有空行或者以注释符号 # 开头的目录都会被 git 忽略 可以使用标准的 glob 模式匹配 匹配模式最后跟反斜杠（/）说明要忽略的目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 bug 分支git 提供了一个 stash 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。git stash修改完 bug 后，回到当前分支上继续干活，工作区是干净的，刚才的工作现场存到哪里去了？git stash list ：查看 stash 列表(stash 是一个栈的结构)git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法：一是用 git stash apply 恢复，但是恢复后，stash 内容并不删除，你需要用 git stash drop 来删除；另一种方式是用 git stash pop ，恢复的同时把 stash 内容也删了；你可以多次 stash ，恢复的时候，先用 git stash list 查看，然后恢复指定的 stash，用命令：git stash apply stash@{0} 配置文件配置 Git 的时候，加上 –global 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了？每个仓库的 Git 配置文件都放在 .git/config 文件中，在这份配置文件中，别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。 查看配置git config -1 设置git push 默认git config --global push.default current 设置别名git config --global alias.&lt;name&gt; &lt;commend&gt;我的设置：git config --global alias.st statusgit config --global alias.cm &quot;commit -m&quot;git config --global alias.ph &quot;push origin &lt;local_repository&gt;:&lt;remote_repository&gt;&quot; 保存用户名和密码对于http(s)协议，可以用下面命令临时缓存git config --global credential.helper cache开启linux缓存git config --global credential.helper wincred开启windows缓存 对于 ssh 协议，可以用 ssh key，具体教程网上很多解决问题问题一git 中执行命令 add .报错：Unlink of file ‘templates/opms.exe’ failed.Should I try again?(y/n) 因为这个文件正在被占用，所以不能添加到暂存区，而正好这个 .exe 文件，我们是不需要添加到版本管理工具的。所以我们选择 n 。 问题二git 中生成 sshkey: ssh-keygen -t rsa -C &quot;youremail&quot;这个email并没有什么用所以我们使用ssh-keygen -t rsa来生成sshkey就可以了。然后git中的配置文件：git config --listgit config --global user.name &quot;yu&quot;git config --global user.email &quot;react.dong.yu@gmail.com&quot;这种配置将会对本地所有的git仓库有效。那么在 push 的时候，远程就知道这个push来自于哪个email.但有时候在公司的时候，有的仓库是公司的，有的仓库是自己github的。这个时候就可以不设置global的配置了，而是在自己的仓库中设置git config --local user.email &quot;react.dong.yu@gmail.com&quot; 问题三使用 windows 的同学注意了，如果你在资源管理器里新建一个 .gitignore 文件，它会提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 .gitignore 了。有些时候，你想添加一个文件到 git，但发现添加不了，原因是这个文件被 .gitignore 忽略了：git add App.class如果你确实想添加该文件，可以用 -f 制添加到 git：git add -f App.class或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了。可以用 git check-ignore 命令检查：git check-ignore -v App.class 问题四为什么我把我生成的 ssh key 添加到了 github 中然后 也 remote 了 https://github.com/Neveryu/Xxx.git为什么提交的时候报错，或者提示 输入密码账号是为什么 ssh key 是 ssh 协议的密钥，http 协议没权限 问题五git怎样删除未监视的文件 untracked files?用 git clean 12345678910111213# 删除 untracked filesgit clean -f # 连 untracked 的目录也一起删掉git clean -fd # 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）git clean -xfd # 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删git clean -nxfdgit clean -nfgit clean -nfd 我的常用命令12git branch -avvgit remote -v 权威教程Pro Git 简体中文版]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2018%2F05%2F12%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[主要内容 Markdown是什么？谁创造了它？为什么要使用它？怎么使用？谁在用？尝试一下 正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 2. 谁创造了它？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 天才都有早逝的归途。 3. 为什么要使用它？ 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. 怎么使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。 Markdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 4.1 标题两种形式：1）使用=和-标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 2）使用#，可表示1-6级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： &gt; 区块引用&gt;&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){ printf(“Hello, Markdown.”);} 代码区块： void main() { printf(&quot;Hello, Markdown.&quot;); }注意:需要和普通段落之间存在空行。 4.5 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，斜体粗体，粗体 4.6 列表使用·、+、或-标记无序列表，如： -（+*） 第一项-（+*） 第二项- （+*）第三项 注意：标记后面最少有一个_空格或制表符_。若不在引用区块中，必须和前方段落之间存在空行。 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 4.8 链接链接可以由两种形式生成：行内式和参考式。 行内式： [younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。 效果： younghz的Markdown库。 参考式： [younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown” 效果： younghz的Markdown库1younghz的Markdown库2 注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。 4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 4.10 反斜杠\相当于反转义作用。使符号成为普通符号。 4.11 符号’`’起到标记作用。如： `ctrl+a` 效果： ctrl+a 5. 谁在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 6. 尝试一下 Chrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。 在线的dillinger.io评价也不错 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。 Linux下的ReText不错。 当然，最终境界永远都是笔下是语法，心中格式化 :)。 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。 以上基本是所有traditonal markdown的语法。 其它：列表的使用(非traditonal markdown)： 用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。 代码库 链接 MarkDown https://github.com/younghz/Markdown MarkDownCopy https://github.com/younghz/Markdown 关于其它扩展语法可参见具体工具的使用说明。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
