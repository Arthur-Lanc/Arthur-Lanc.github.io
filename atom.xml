<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arlanx&#39;s Blog</title>
  
  <subtitle>O ever youthful, O ever powerful.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-03T14:08:19.115Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Arlanx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>垄断和竞争</title>
    <link href="http://yoursite.com/2019/07/03/eco-monopoly/"/>
    <id>http://yoursite.com/2019/07/03/eco-monopoly/</id>
    <published>2019-07-03T14:03:47.000Z</published>
    <updated>2019-07-03T14:08:19.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-The-awareness-of-monopoly"><a href="#1-The-awareness-of-monopoly" class="headerlink" title="1 . The awareness of monopoly"></a><strong><em>1 . The awareness of monopoly</em></strong></h2><p>垄断会造成商品价格比较多竞争者参与的情况更高，但其实这一意识早在亚里士多德时代就已经被唤起，他以泰勒斯的故事警告人们垄断的后果。<br><strong><em>泰勒斯（Thales）</em></strong> 是亚里士多德的先贤，古希腊思想家、哲学家，公认的“哲学第一人”。他曾是一个商人，但是他不好好经商，一心扑在哲学问题上，所以当时的人们嘲笑泰勒斯的哲学实践，认为哲学是没有用处的东西，不能产生任何的经济效益。泰勒斯为了证明人们的观念是错误的，用收购橄榄榨汁机进行反击。他在冬天收购了所有的机器，等到夏天的时候，人们开始需要它的时候，泰勒斯再以昂贵的价格卖出去，因为泰勒斯的垄断力量，人们别无选择，所以他狠赚了一笔。他以此证明哲学家不是不想赚钱，他可以赚很多钱，只是还有更重要的事去做。<br>从泰勒斯赚钱的过程来看，这个故事告诉了人们，垄断的潜在力量不容忽视。</p><a id="more"></a><hr><h2 id="2-Market-power"><a href="#2-Market-power" class="headerlink" title="2 . Market power"></a><strong><em>2 . Market power</em></strong></h2><p>在穆勒发表的 <strong><em>《政治经济学原理》（Principles of Political economy,1848）</em></strong> 一书中汇集了很多“垄断和价格的关系”的思想。<strong>一个普遍的观点是，有些行业本身就倾向于发展成垄断行业</strong>。其原因有两方面，一是政府对进口产品征收关税，二是生产商逐渐壮大的自然结果。<br>在工业革命时期，煤炭、铁路和水的供给都表现出了这种垄断倾向性。大型生产商通过占领足够的市场份额获得资金，而那些缺乏资金的小企业将会出局，市场价格被抬高。<br>铁路行业垄断是工业革命时期比较典型的例子，早期占领市场的铁路公司修建的铁路和提供的服务会具有优势，而后来的新铁路可能又贵又不实用。此外，像通信这样的行业，基础设施的建设规模庞大，如果多个生产商同时提供服务，可能谁都没有办法支付这样高昂的费用。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1559613352_139337298" alt="1.jpg"><br>==The Railways in the Industrial Revolution，图片来自thoughtco.com==<br>这样的市场条件，卡特尔也很有可能出现，从同样都是抬高价格来看，消费者面临的情况并不比垄断好多少。</p><hr><h2 id="3-Monopoly-worker"><a href="#3-Monopoly-worker" class="headerlink" title="3 . Monopoly worker"></a><strong><em>3 . Monopoly worker</em></strong></h2><p>穆勒意识到，劳动力市场也存在着垄断。比如同等技术水平 <strong><em>金匠（goldsmith）</em></strong> ，人们会认为信誉高的金匠比信誉低的工资高很多。这样一来，金匠行业的门槛会很高，处在高水平的人就可以制定垄断性的价格。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1559613401_261454311" alt="2.jpg"><br>==Goldsmith，图片来自humbs.dreamstime.com==<br>这样的特权垄断在劳动力市场并不是个例。大部分的工人阶级都不能进入技术行业，因为这些行业大多要求工人具有多年的教育和培训经验，培养这样的工人需要不菲的费用，大多数家庭支付不起，所以他们也无法享受高薪。有特权的工人也会排斥可能会和他们竞争的工人。</p><hr><h2 id="4-Monopoly-and-welfare"><a href="#4-Monopoly-and-welfare" class="headerlink" title="4 . Monopoly and welfare"></a><strong><em>4 . Monopoly and welfare</em></strong></h2><p>从19世纪90年代末开始，英国经济学家阿尔弗雷德·马歇尔详细地分析了垄断家价格对价格和消费者 <strong><em>福利（welfare）</em></strong> 的影响。<br>在阐述这一问题时，他用公式阐述了 <strong><em>消费者剩余（consumer surplus）</em></strong>，即消费者愿意支付的最高价格和实际支付价格之间的差额，即图中红色区域。<strong><em>生产者剩余（producer surplus）</em></strong> 等于卖者出售一种物品或服务得到的价格减去卖者的成本，即图中蓝色区域。总剩余（total surplus）是指消费者剩余和生产者剩余的总和，也是社会总福利（welfare），即红蓝区域之和。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1559613471_46705846" alt="3.png"><br>==Diagram illustrating consumer and producer surplus at equilibrium for general supply and demand curves，图片来自维基==<br>当讨论垄断和完全竞争的时候，我们把原书中的图拆开来看，二者曲线图如图所示（上：垄断，下：完全竞争）：<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1559613524_327833139" alt="4.png"><br><img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1559613613_919340581" alt="5.png"><br>通过对比以上两图红蓝区域面积之和即可得出，完全竞争市场比垄断市场带来的社会福利更高。</p><hr><h2 id="5-John-Stuart-Mill"><a href="#5-John-Stuart-Mill" class="headerlink" title="5 . John Stuart Mill"></a><strong><em>5 . John Stuart Mill</em></strong></h2><p>在今天的课程中我们提到穆勒在 <strong><em>《政治经济学原理》</em></strong> 一书中集中了经济学家们有关“竞争的缺乏是否会导致价格上升”这一问题的大部分思想，这和他所处的时代有很大关系。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1559613565_243138299" alt="6.jpg"><br>==John Stuart Mill，图片来自维基==<br>穆勒全名为 <strong><em>约翰·斯图亚特·穆勒（John Stuart Mill）</em></strong>,1806年生于英国伦敦，时值英国第一次工业革命（18世纪60年代-19世纪中期），人类社会进入蒸汽时代。这一时期的资本阶级日益壮大，与无产阶级的矛盾也越来越尖锐。因为市场对工业革命有着推动作用，很多经济学家都着手分析当时的经济现象。<br>穆勒小时候家境殷实，家族成员都是智慧的化身。但是穆勒的父亲对他要求十分严格，为了让穆勒继承和发展他在哲学方面的研究，穆勒从3岁开始就接受着高难度的课程和希腊文，8岁开始学拉丁文、代数、几何，9岁读遍希腊史家的重要著作。这样的高强度教育让穆勒在20几岁就出现了精神问题。<br>在这段时间里他不断思索作为一个人的价值何在，并且渐渐从 <strong>英国浪漫主义诗人华兹华斯（1770-1850）</strong> 的诗中得到一些启发。五年后精神危机慢慢过去，他的思想进入了一个崭新的阶段。除了在经济学方面的成就，他还是那个时代拥有雄辩的口才并敢于发声的人，<strong>不仅为法国大革命和妇女权利做辩护，还公开反对奴隶制</strong>。穆勒的妻子泰勒Harriet Taylor是一位女权倡导者，在遇见穆勒之前已经嫁人，双方因为穆勒对妇女权利的追求而相识。此后两人的情谊日以深厚，通过书信等方式讨论了很多关于性和婚姻的问题。因为Taylor的家事，穆勒和她纠缠了20年，后来Taylor的丈夫去世，两年后她才和穆勒结婚，并对穆勒撰写女性权利的文章提供很多灵感。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-The-awareness-of-monopoly&quot;&gt;&lt;a href=&quot;#1-The-awareness-of-monopoly&quot; class=&quot;headerlink&quot; title=&quot;1 . The awareness of monopoly&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;1 . The awareness of monopoly&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;垄断会造成商品价格比较多竞争者参与的情况更高，但其实这一意识早在亚里士多德时代就已经被唤起，他以泰勒斯的故事警告人们垄断的后果。&lt;br&gt;&lt;strong&gt;&lt;em&gt;泰勒斯（Thales）&lt;/em&gt;&lt;/strong&gt; 是亚里士多德的先贤，古希腊思想家、哲学家，公认的“哲学第一人”。他曾是一个商人，但是他不好好经商，一心扑在哲学问题上，所以当时的人们嘲笑泰勒斯的哲学实践，认为哲学是没有用处的东西，不能产生任何的经济效益。泰勒斯为了证明人们的观念是错误的，用收购橄榄榨汁机进行反击。他在冬天收购了所有的机器，等到夏天的时候，人们开始需要它的时候，泰勒斯再以昂贵的价格卖出去，因为泰勒斯的垄断力量，人们别无选择，所以他狠赚了一笔。他以此证明哲学家不是不想赚钱，他可以赚很多钱，只是还有更重要的事去做。&lt;br&gt;从泰勒斯赚钱的过程来看，这个故事告诉了人们，垄断的潜在力量不容忽视。&lt;/p&gt;
    
    </summary>
    
      <category term="Economic" scheme="http://yoursite.com/categories/Economic/"/>
    
      <category term="Awareness Of Monopoly" scheme="http://yoursite.com/categories/Economic/Awareness-Of-Monopoly/"/>
    
    
      <category term="Monopoly" scheme="http://yoursite.com/tags/Monopoly/"/>
    
      <category term="Welfare" scheme="http://yoursite.com/tags/Welfare/"/>
    
      <category term="Mill" scheme="http://yoursite.com/tags/Mill/"/>
    
  </entry>
  
  <entry>
    <title>供需平衡的数学模型</title>
    <link href="http://yoursite.com/2019/07/02/eco-distort-market/"/>
    <id>http://yoursite.com/2019/07/02/eco-distort-market/</id>
    <published>2019-07-02T14:29:29.000Z</published>
    <updated>2019-07-02T14:37:52.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Distorting-the-market"><a href="#1-Distorting-the-market" class="headerlink" title="1. Distorting the market"></a><em><strong>1. Distorting the market</strong></em></h2><p>截至19世纪早期，工业革命的影响已经从英国扩大到世界范围内，让很多国家走入了工业经济，促进了经济结构的根本性变革。在这一时期，对商人的关注转向了拥有资本的生产者，这些 <em><strong>新“统治阶级”的出现</strong></em> 是最明显的社会改变。同时，制造商品的公司数量稳步上涨，很多公司都通过股票市场来出售公司的股份。<br>在以新的方式思考经济的同时，新的社会和政策问题也随之出现。斯密曾在1776年警示世人，_<strong>大生产商会通过垄断或卡特尔主导市场，生产较少的产品而将价格定得很高</strong>_。即使只有几个生产者来控制，即使管控能够避免这种现象的发生，这种策略还是能很轻易地 _<strong>扭曲市场的竞争力（distort the competitiveness of the market）</strong>_。斯密“人是理性的”这一观点，在投资者都冲入市场中购买那些被夸大价值的股票时，成为了经济泡沫产生的原因之一。</p><a id="more"></a><p><img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557997476_197886492" alt="图片1.pnghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557997476_197886492"><br>==Economic bubble，图片来自durise.com==<br>[<em><strong>经济泡沫(economic bubble)</strong>_：一系列资产 (尤其是虚拟资本) 价格膨胀，使其市场价格远远超过了它实际代表的价值，形成虚假繁荣和含有过多“泡沫” 的经济总量。]<br>但是，Léon Walras和Vilfredo Pareto仍然认为市场经济能够实现均衡，并决定产量和价格。Alfred Marshall解释了供求关系以及它们和价格是如何在 _<strong>完全竞争市场（perfect competition）</strong></em> 中相互作用的。<br>[<em><strong>完全竞争市场（perfect competition）</strong></em> 指一个行业中有非常多的生产或销售企业，它们都以同样的方式向市场提供同类的、标准化的产品，买卖双方对于商品或劳务的价格均不能控制。在这种竞争环境中，_<strong>产品价格只能随供求关系而定</strong>_。]<br>有关于物价的问题是这一时期经济学家关心的一大问题，他们的研究方向从道德哲学的角度转向了效用角度，不再是原材料加劳动力这么简单。</p><hr><h2 id="2-Marx’s-theory-of-value"><a href="#2-Marx’s-theory-of-value" class="headerlink" title="2. Marx’s theory of value"></a><em><strong>2. Marx’s theory of value</strong></em></h2><p><em><strong>马克思</strong></em> 是这一时期最重要的经济学家之一，他对资本有着不同以往的看法，其观点在当时看来是颠覆性的。他认为市场经济的不平等是因为资本家对工人阶级的剥削，并 <em><strong>主张通过前瞻性革命来取代资本主义</strong>_，将其视为经济发展的下一个阶段：一个 _<strong>社会主义国家</strong>_，其中生产资料由工人拥有，最终废除私有财产。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557997487_727820967" alt="图片2.pnghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557997487_727820967"><br>==Exploitation，图片来自fee.org==<br>虽然马克思的理论正逐渐在世界范围内应用，但是书中认为，市场经济还在持续操作着另一半的世界，</em><strong>奥地利学派（Austrian school）</strong>_ 在用数学模型反对社会主义时异军突起。虽然自由市场经济在1929年的华尔街危机中受到质疑，计划经济上线，但是新古典经济学家仍然在20世纪末为自由市场经济扳回一盘。总的来说，经济学家们还是在为资本主义做辩护，认为它是促进繁荣的最好方式。</p><hr><h2 id="3-Duelling-duopolies-双寡头垄断的决斗"><a href="#3-Duelling-duopolies-双寡头垄断的决斗" class="headerlink" title="3. Duelling duopolies (双寡头垄断的决斗)"></a><em><strong>3. Duelling duopolies (双寡头垄断的决斗)</strong></em></h2><p>需求和供给受到多种因素的影响不断变化，而在不同的竞争条件下，<em><strong>如何平衡供求关系使利益最大化</strong></em> 是公司一直关注的问题。<br>十七世纪中后期，经济学家开始观察垄断和激烈的竞争对市场产生的影响。它们发现垄断总是通过限制产量来让价格和利润到达较高的水平。当大量的竞争者出现，价格会跌至成本水平，利润降低，产量升高。法国经济学家 <em><strong>安东尼·奥古斯汀·库尔诺（Antoine Augustin Cournot）</strong></em> 对这些问题很感兴趣，他讨论了有限的竞争对市场的影响，是第一个用图表解释供求关系的人。<br>库尔诺的模型是基于销售同种矿泉水的两个公司，这两个公司在矿泉水市场中是双寡头，该模型被称为 <em><strong>双寡头模型（Duopoly model）</strong>_，又因为库尔诺的名字也被翻译成古诺，所以也有古诺模型和古诺双寡头模型的叫法。<br>应用数学模型之前，_首先要确定该模型发生的条件_。这两个公司不允许形成卡特尔，也没有其他的公司进入该产业的争夺，两个公司必须同时决定他们向市场供给多少矿泉水产品。_其次规定_，产业的总产出等于两个公司决定产出之和。每个公司 _要基于对手公司的想法来做决策_，使利润最大化。<br>如图所示，在极端情况下，如果公司A认为B什么都不产出，他将用垄断的产量最大化利益，此时15是垄断产量。相反，如果A认为B会高产量输出，那么此时矿泉水的价格会很低，如此低的价格迫使A停止生产。通过分别连接极端情况下的点，就形成了两条线。这两条线被称之为“反应曲线”（reaction curve），而均衡点则是两条线的交点，</em><strong>表示当两个公司供给相同时，每个公司的利润都能达到最大化</strong>_。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557997497_570723825" alt="图片3.pnghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557997497_570723825"><br>==Duopoly model，图片来自原书==<br>这种均衡是我们之前在介绍博弈论中提到的纳什均衡（Nash Equilibrium），是博弈论的核心，也是分析公司和个人反应策略在现代经济学中的分支。<br>根据双寡头垄断模型，库尔诺证明 _<strong>双寡头的产出量多于单一垄断但是低于完全竞争市场</strong>_。所以对于社会来说，完全竞争市场优于寡头市场，寡头市场优于单一垄断。</p><hr><h2 id="4-Extended-model"><a href="#4-Extended-model" class="headerlink" title="4. Extended model"></a><em><strong>4. Extended model</strong></em></h2><p>从以上角度出发，库尔诺逐渐将更多的竞争者加入到市场中，这样就越来越接近完全竞争市场。后来，这一模型被法国经济学家 <em><strong>伯特兰德Joseph Bertrand</strong></em> 发展，他认为 _<strong>如果公司更看重价格水平而不是产量，那么双寡头的均衡就和完全竞争市场一致了</strong>_。因为任何公司定高价必然遭到其他公司的削价（undercut），这样的话，价格就会趋于最有竞争力的水平。</p><hr><h2 id="5-Antoine-Augustin-Cournot"><a href="#5-Antoine-Augustin-Cournot" class="headerlink" title="5. Antoine Augustin Cournot"></a><em><strong>5. Antoine Augustin Cournot</strong></em></h2><p><img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557997508_349282614" alt="图片4.pnghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557997508_349282614"><br>==Antoine Augustin Cournot，图片来自维基==<br>_<strong>安东尼·奥古斯汀·库尔诺（Antoine Augustin Cournot）1801年出生于法国</strong>_，是一位酷爱阅读的人。虽然家庭并不富裕，但他仍受教于著名的巴黎高等师范学校，获巴黎大学工程学博士学位，在数学、科学、哲学和经济学方面都有所造诣。尽管饱受视力顽疾的折磨，他仍然在完全看不见之前用数学的方法去解释经济并撰写文章。<br>从理论思潮上看，库尔诺生不逢时。当时法国学术界关注的是对大革命的争论以及日益增长的社会主义思潮，库尔诺的理论游走在不被人注意的边缘。加上他本人性情内向，性格孤僻，也不关心自己的作品是否有吸引力，至死都默默无闻。后来，著名经济学家杰文斯等人才注意到库尔诺著作的深远意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Distorting-the-market&quot;&gt;&lt;a href=&quot;#1-Distorting-the-market&quot; class=&quot;headerlink&quot; title=&quot;1. Distorting the market&quot;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;1. Distorting the market&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;截至19世纪早期，工业革命的影响已经从英国扩大到世界范围内，让很多国家走入了工业经济，促进了经济结构的根本性变革。在这一时期，对商人的关注转向了拥有资本的生产者，这些 &lt;em&gt;&lt;strong&gt;新“统治阶级”的出现&lt;/strong&gt;&lt;/em&gt; 是最明显的社会改变。同时，制造商品的公司数量稳步上涨，很多公司都通过股票市场来出售公司的股份。&lt;br&gt;在以新的方式思考经济的同时，新的社会和政策问题也随之出现。斯密曾在1776年警示世人，_&lt;strong&gt;大生产商会通过垄断或卡特尔主导市场，生产较少的产品而将价格定得很高&lt;/strong&gt;_。即使只有几个生产者来控制，即使管控能够避免这种现象的发生，这种策略还是能很轻易地 _&lt;strong&gt;扭曲市场的竞争力（distort the competitiveness of the market）&lt;/strong&gt;_。斯密“人是理性的”这一观点，在投资者都冲入市场中购买那些被夸大价值的股票时，成为了经济泡沫产生的原因之一。&lt;/p&gt;
    
    </summary>
    
      <category term="Economic" scheme="http://yoursite.com/categories/Economic/"/>
    
      <category term="Distorting The Market" scheme="http://yoursite.com/categories/Economic/Distorting-The-Market/"/>
    
    
      <category term="Perfect Competition" scheme="http://yoursite.com/tags/Perfect-Competition/"/>
    
      <category term="Economic Bubble" scheme="http://yoursite.com/tags/Economic-Bubble/"/>
    
      <category term="Duopoly Model" scheme="http://yoursite.com/tags/Duopoly-Model/"/>
    
      <category term="Marx" scheme="http://yoursite.com/tags/Marx/"/>
    
  </entry>
  
  <entry>
    <title>比较优势与绝对优势</title>
    <link href="http://yoursite.com/2019/07/01/eco-comparative-adavantage/"/>
    <id>http://yoursite.com/2019/07/01/eco-comparative-adavantage/</id>
    <published>2019-07-01T14:53:29.000Z</published>
    <updated>2019-07-01T15:15:50.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Comparative-advantage"><a href="#1-Comparative-advantage" class="headerlink" title="1 . Comparative advantage"></a><strong><em>1 . Comparative advantage</em></strong></h2><p>在李嘉图之前，斯密提出了 <strong><em>绝对优势（absolute advantage）</em></strong> ，来描述一个人或者国家，相对于其竞争者而言，消耗一单位资源的产出更多。比如，不同气候环境下的葡萄牙和英国，葡萄牙可以比英国制造更多葡萄酒，英国可以产出比葡萄牙更多的羊毛。这时，我们可以说葡萄牙在葡萄酒制造上有绝对优势，英国在羊毛制品上有绝对优势。</p><a id="more"></a><p><strong><em>比较优势（comparative advantage）</em></strong> 是李嘉图在绝对优势上的发展，讨论一个国家在两种商品上都具有绝对优势时的情形。这种情形可以转化成两个人做鞋子和帽子来解释。两个工人都可以做鞋子和帽子，其中工人A是制造的一把好手，在两个商品上的制作能力都比工人B强，这时他们该如何选择达到利益最大化呢？<br>假设具有制造优势的工人A在制造帽子的时候比工人B强20%，而在造鞋子的时候强50%，这时他应该去造鞋子，把造帽子的任务留给工人B。<br>为什么？<br>因为工人A十分善于制造鞋子，如果他花费时间做帽子，那么他每做一个帽子就会失去更多鞋子生产的价值。即使工人B做帽子和鞋子的功夫都没有工人A好，但他做帽子的成本是要低于A的。这时，我们就说，工人B在做帽子上具有比较优势，而工人A在制造鞋子上有比较优势。<br>回到国家层面上，如果国家专注于比较优势，商品的总量将会上涨，更多更实惠的商品会在国家之间贸易输送，那些在某些处商品于绝对劣势的国家，也仍然可以以有利的方式出口它们。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557998863_5883198" alt="1.jpghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557998863_5883198"><br>==Comparative advantage persuades free trade，图片来自tutorschooleconomics.wordpress.com==</p><hr><h2 id="2-There-may-be-losers-as-well-as-winners"><a href="#2-There-may-be-losers-as-well-as-winners" class="headerlink" title="2. There may be losers as well as winners"></a><strong><em>2. There may be losers as well as winners</em></strong></h2><p>什么决定了比较优势呢？<br>瑞典经济学家Eli Heckscher和Bertil Ohlin认为比较优势与国家的资本和劳动力相关。<strong><em>资本丰富的国家（capital-rich country）</em></strong> 在资本密集的机器制造产品具有比较优势，<strong><em>劳动力丰富的国家(labour-rich country)</em></strong> 在农产品等方面具有比较优势。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557998919_107940932" alt="2.jpghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557998919_107940932"><br>==图片来自谷歌==<br>比较优势不仅可以缩小价格之间的差异，还可以减少工资之间的不同。在劳动密集的专业化国家，工资指数倾向于被抬高，而在资本密集型国家则呈反方向趋势。所以即使总量上升，在这场博弈中也有输有赢，继而有人反对开放贸易。<br>如今的贸易保护的呼声和李嘉图时代别无二致。2009年，中国指控美国 <strong><em>猖獗的贸易保护主义（“rampant protectionism”）</em></strong> ，对中国进口到美国的汽车轮胎征收重税。这种情况发生的原因是美国的轮胎进口使得本土的轮胎产量严重下滑，工厂倒闭，工人失业，政府迫于压力对进口轮胎加税。而中国采取的报复性措施是对美国的汽车和家禽增加进口税。<br><strong><em>关税（tariff）</em></strong> 上的拉扯注定导致经济上的波澜，美国从增税轮胎那里获得的保护，被其他的消极影响抵消：高昂的轮胎价格使美国在轮胎市场上失去了竞争力，出口产业也受到报复，虽然拯救了轮胎工人却把别的行业推向工人失业危机。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557999000_345942806" alt="3.jpghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557999000_345942806"><br>==Sino-US tariff dispute，图片来自abm-website-assets.s3.amazonaws.com==<br>为什么美国明知这样做会损害经济还继续推行这样的政策？美国经济学家Manicur Olson解释道，反对关税的通常是美国几个大型的制造商和员工，他们虽然数量较少，但是如此庞大的产业却因为价格低廉的进口商品受到了肉眼可见的创伤。</p><hr><h2 id="3-Contemporary-trade"><a href="#3-Contemporary-trade" class="headerlink" title="3 . Contemporary trade"></a><strong><em>3 . Contemporary trade</em></strong></h2><p>很多经济学家支持李嘉图在贸易上的观点，认为它帮助了国家的工业化进程。美国经济学家David Dollar 和Aart Kraay 认为在过去的几十年中，贸易帮助发展中国家发展，使他们减少贫困，那些减少关税的国家发展得更快，贫困消除得更多。<br>有人对贸易是否能帮助发展中国家发展提出了质疑。美国经济学家Joseph Stiglitz认为发展中国家也会遭遇市场失灵和 <strong><em>政策上的弱点（institutional weaknesses）</em></strong> ，这些问题会导致贸易自由化过快，代价更高。<br>这是源于经济学家们意识到理论和实践间的<strong>矛盾（contradictions）</strong>。印度政府移除关税后，从印度尼西亚进口的物美价廉的棕榈油让人民的生活水平得到了提高，这一点和理论上是匹配的。但是棕榈油的推广摧毁了当地1,000,000多户花生农场的营生。按照李嘉图的理论，这些农民会转行生产别的商品，但事实是他们没有。因为他们<strong>投入的资本是不动产(their investment in capital is immobile)</strong>，人可以走，种的东西可以变，但是那些用来处理花生的机器却不能用于别的生产。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557999078_331020509" alt="4.jpghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557999078_331020509"><br>==peanut oil machine，图片来自imimg.com==<br>欧洲以及亚洲四小龙（中国香港、中国台湾、新加坡和韩国）的发展路线都是在贸易开放前实行贸易保护以提高自己比较优势的技能，但是李嘉图的批评者认为理论和实践间的矛盾在长期流通中会<strong>阻碍那些更贫穷国家的工业化进程和多样化发展（hamper the industrialization and diversification of poorer countries）</strong>，而一个国家具体如何建立自己的比较优势也比李嘉图的理论要复杂的多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Comparative-advantage&quot;&gt;&lt;a href=&quot;#1-Comparative-advantage&quot; class=&quot;headerlink&quot; title=&quot;1 . Comparative advantage&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;1 . Comparative advantage&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在李嘉图之前，斯密提出了 &lt;strong&gt;&lt;em&gt;绝对优势（absolute advantage）&lt;/em&gt;&lt;/strong&gt; ，来描述一个人或者国家，相对于其竞争者而言，消耗一单位资源的产出更多。比如，不同气候环境下的葡萄牙和英国，葡萄牙可以比英国制造更多葡萄酒，英国可以产出比葡萄牙更多的羊毛。这时，我们可以说葡萄牙在葡萄酒制造上有绝对优势，英国在羊毛制品上有绝对优势。&lt;/p&gt;
    
    </summary>
    
      <category term="Economic" scheme="http://yoursite.com/categories/Economic/"/>
    
      <category term="Comparative advantage" scheme="http://yoursite.com/categories/Economic/Comparative-advantage/"/>
    
    
      <category term="Economic" scheme="http://yoursite.com/tags/Economic/"/>
    
      <category term="Ricardo" scheme="http://yoursite.com/tags/Ricardo/"/>
    
      <category term="Tariff" scheme="http://yoursite.com/tags/Tariff/"/>
    
  </entry>
  
  <entry>
    <title>经济的增长和衰退就像是悠悠球一样来回摆动</title>
    <link href="http://yoursite.com/2019/06/30/eco-boom-and-bust/"/>
    <id>http://yoursite.com/2019/06/30/eco-boom-and-bust/</id>
    <published>2019-06-30T13:28:42.000Z</published>
    <updated>2019-06-30T13:41:49.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Boom-and-bust"><a href="#1-Boom-and-bust" class="headerlink" title="1. Boom and bust"></a><em><strong>1. Boom and bust</strong></em></h2><p>商业周期是在经济增长（boom）和经济衰退（bust）或停滞（stagnation）之间来回转换的。<em><strong>西斯蒙第（Jean-Charles Sismondi）</strong></em> 第一个认知到经济危机周期的存在，而后法国人 <em><strong>迪努瓦耶Charles Dunoyer</strong></em> 揭示了周期的形式。</p><a id="more"></a><p>西斯蒙第挑战了相信市场机制可以快速实现供需均衡并提供就业的斯密等人，认为供需平衡最终会实现，但是一定是要经过“很多可怕的痛苦的”过程。在他的著作《政治经济学新原理》（New Principles of Political Economy, 1819）发表前，很多经济学家都忽视了经济的周期繁荣和衰退，并通常归结为战争等外部原因。在西斯蒙第的理论中，<em><strong>经济变动是市场生产过剩和消费低迷的的结果，而这种结果又是繁荣时期的发展不平衡所带来的</strong>_。<br>西斯蒙第在自由政策和国家干预中站在 _<strong>国家干预</strong></em> 一方，认为国家对财富的管控才能避免经济周期的危机。</p><hr><h2 id="2-Fuelling-the-boom"><a href="#2-Fuelling-the-boom" class="headerlink" title="2. Fuelling the boom"></a><em><strong>2. Fuelling the boom</strong></em></h2><p>经济的增长和衰退就像是悠悠球一样来回摆动：<br><img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557903422_748462614" alt="图片1.pnghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557903422_748462614"><br>==yo-yo，图片来自cdn4.iconfinder.com==<br>经济发展使商业繁荣，工人的薪水增加，可以购买更多的商品，为经济增常提供燃料动力（fuelling）。商品销售量上升，公司规模随之扩大，新的员工加入，消费水平持续上升。<br>与此同时，企业间的竞争加大，公司通过过度生产来赚取利润，直到供过于求的情况出现。此时他们不得不降低价格，减少利润，面临裁员，进入到衰退的阶段。<br>而当价格降到足够低，可以刺激需求的时候，这个悠悠球就又开始摆动起来了。<br>1825年的恐慌（Panic of 1825）印证了经济周期的存在，当时的股票崩盘是第一个可追溯的因为内部经济事件所导致的危机，它促成了英国六家伦敦银行和六十家国家银行的关闭，其萌芽源自一个不可思议的投机性投资骗局——_<strong>波亚斯（Poyias）</strong>_。<br>波亚斯是由麦格雷戈尔 _<strong>虚构的国家</strong>_，那里土地肥沃，玉米一年三熟；河水澄澈纯净，河床下遍布黄金，好似一个世外桃源。书写的真实是一回事，但是会营销懂金融的骗子才是真正厉害的骗子(con man)。<br>麦格雷戈尔举办宴会，邀请伦敦各界名流出入，和现在请明星代言差不多。而后他设计了波亚斯国家的货币，售卖并不存在的波亚斯国家的土地，同时向英国民众发行国债，鼓励英国人将英镑兑换成波亚斯币，在债券市场上骗得130万英镑，相当于现在36亿英镑。后来骗局被揭穿，麦格雷戈尔入狱，但是“波亚斯”产生的经济动荡余波（repercussions）已经无法挽回。<br><img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557903569_249464627" alt="图片2.pnghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557903569_249464627"><br>==A Bank of Poyais “dollar”，图片来自维基==</p><hr><h2 id="3-Early-trade-protection"><a href="#3-Early-trade-protection" class="headerlink" title="3. Early trade protection"></a><em><strong>3. Early trade protection</strong></em></h2><p>15世纪到17世纪中叶是重商主义的重要发展时期，虽然在中间有重农学派的影响，但直至18世纪，重商主义在欧洲大陆仍占有重要地位。在英国产业革命的迅速发展中，运用了重商主义思想的 <em><strong>《谷物法》（Corn Laws, 1815）</strong></em> 问题曾成为当时重要的经济和政治问题。<br>在拿破仑战争期间，从欧洲大陆进口小麦是十分困难的，所以英国的小麦价格飙升，很多地主都增加了种植小麦土地的比例。然而，从经济周期来看，小麦的大量生产会使价格降低。这时，在国会中有控制权的地主通过《谷物法》，规定谷物价格在一夸特低于80先令的时候，禁止国外谷物进口，以维持国内谷物高价。这确实保护了农民和地主，但小麦价格超出了穷人可以支付的范围，工业资产阶级和农业资产阶级的斗争日益激烈。<br><img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557903586_250651096" alt="图片3.pnghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557903586_250651096"><br>==A meeting of the Anti-Corn Law League in Exeter Hall in 1846，图片来自维基==<br>李嘉图就生于这个时代，他认为保护政策在长期的流通中会限制国家增加财富的能力。同时，他对《谷物法》持有反对意见，声称这些法律会使英国变得更穷，并发展出一种理论，这种理论已经成为所有希望为自由贸易辩护的人的主要支柱，我们将在明天的内容中学习这个理论。</p><hr><h2 id="4-David-Ricardo"><a href="#4-David-Ricardo" class="headerlink" title="4. David Ricardo"></a><em><strong>4. David Ricardo</strong></em></h2><p><img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557903593_710422769" alt="图片4.pnghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557903593_710422769"><br>==David Ricardo，图片来自维基==<br>李嘉图1772年生于犹太资产阶级家庭，父亲是富有的伦敦交易所经纪人。李嘉图只受过初等教育，在14岁时便和父亲在交易所工作，对金融业务非常熟悉。21岁时，他与教友会教徒Priscilla Wilkinson相恋，宗教信仰的不同使李嘉图和父亲发生矛盾，私奔后独立生活，建立了自己的股票公司。因为他善于钻研和把握时机，在25岁时就相当富有。</p><hr><h2 id="5-知识拓展-Bull-and-bear-markets"><a href="#5-知识拓展-Bull-and-bear-markets" class="headerlink" title="5.知识拓展-Bull and bear markets"></a><em><strong>5.知识拓展-Bull and bear markets</strong></em></h2><p>和经济的整体繁荣和衰落一样，市场也会有上升和下降。价格维持上升趋势的市场称为 <em><strong>牛市（bull market）</strong>_，而价格下降的被称为 _<strong>熊市（bear market）</strong>_。这样的市场标签可以运用在股票、债券和购房市场中。牛市经常出现在经济增长时期，投资者对于经济发展持乐观态度并购买股票，提高财产价值。熊市到来，投资者开始像熊一样“看跌”（bearish），抛售财产。<br><img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557903598_596872661" alt="图片5.pnghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557903598_596872661"><br>==Bull market VS Bear market，图片来自avantfx.com==<br>为什么是牛和熊？<br>关于它们名字来的来源尚不明确，以下是两种最常见的解释：<br>“熊”和“牛”这两个词被认为源于动物攻击其对手的方式。也就是说，公牛会把它的角向上倾斜，而熊会向下滑动。这些行为与市场的变动相关：如果趋势上升，它被认为是牛市; 如果趋势下降，那就是熊市。<br>因为在西方古代文明中，</em><strong>牛代表着力量、财富和希望</strong>_，而熊代表着 _<strong>抑制狂热、消化自身、见机重生</strong>_。古罗马传说中，一头逃走的烈性野牛被杀后，它的肉身化成覆盖大地的植被，它的脊柱化为小麦，它的血管化为藤类植物，它的精子变成各种对人有益的动物。牛牺牲了自身，但使万物获得诞生。因此人们用“牛市”表示对财富的期盼。<br>熊也是古代西方人崇拜的对象。在冬眠期的5个月内，熊可以随时清醒，甚至可以怀孕育崽。当春天来临，熊再返地面。人们用“熊”表示跌市，其深远意义在于：股市的调整是不为人们的意志所左右的（像熊一样不能驯化），这个名字告诉人们要像熊一样，在必要的时候从喧嚣中归隐起来，耐心等待，直到重生机会的来临。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote><p>Panic of 1825：<br><a href="https://en.wikipedia.org/wiki/Panic_of_1825" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Panic_of_1825</a><br>Poyais：<br><a href="https://en.wikipedia.org/wiki/Gregor_MacGregor" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Gregor_MacGregor</a><br>David Ricardo：<br><a href="https://en.wikipedia.org/wiki/David_Ricardo#Personal_life" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/David_Ricardo#Personal_life</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Boom-and-bust&quot;&gt;&lt;a href=&quot;#1-Boom-and-bust&quot; class=&quot;headerlink&quot; title=&quot;1. Boom and bust&quot;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;1. Boom and bust&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;商业周期是在经济增长（boom）和经济衰退（bust）或停滞（stagnation）之间来回转换的。&lt;em&gt;&lt;strong&gt;西斯蒙第（Jean-Charles Sismondi）&lt;/strong&gt;&lt;/em&gt; 第一个认知到经济危机周期的存在，而后法国人 &lt;em&gt;&lt;strong&gt;迪努瓦耶Charles Dunoyer&lt;/strong&gt;&lt;/em&gt; 揭示了周期的形式。&lt;/p&gt;
    
    </summary>
    
      <category term="Economic" scheme="http://yoursite.com/categories/Economic/"/>
    
      <category term="Boom and bust" scheme="http://yoursite.com/categories/Economic/Boom-and-bust/"/>
    
    
      <category term="Economic" scheme="http://yoursite.com/tags/Economic/"/>
    
      <category term="Poyias" scheme="http://yoursite.com/tags/Poyias/"/>
    
      <category term="Ricardo" scheme="http://yoursite.com/tags/Ricardo/"/>
    
  </entry>
  
  <entry>
    <title>市场供求关系的形成</title>
    <link href="http://yoursite.com/2019/06/29/eco-over-production/"/>
    <id>http://yoursite.com/2019/06/29/eco-over-production/</id>
    <published>2019-06-29T13:57:50.000Z</published>
    <updated>2019-06-29T14:06:10.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-The-impossibility-of-overproduction"><a href="#1-The-impossibility-of-overproduction" class="headerlink" title="1 . The impossibility of overproduction"></a><strong><em>1 . The impossibility of overproduction</em></strong></h2><p>斯密在撰写《国富论》时就注意到，商人常常将生意的失败与资金匮乏和生产过剩联系在一起。斯密通过阐述货币在经济中的职能揭穿（debunk）了所谓资金匮乏的真相，而后者则被法国经济学家让·巴提斯特·萨伊（Jean-Baptiste Say）在他的《政治经济学概论》（A Treatise on Political Economy, 1803）中驳回。</p><a id="more"></a><p>萨伊认为，<strong><em>生产过剩是不存在的（over-production is impossible）</em></strong>：一旦商品生产出来就会为其他的商品创造市场。比如，一个裁缝制造和卖出衣服的钱，马上会被用来买面包和啤酒，面包和啤酒就有了市场。<br>萨伊认为人们没有 <strong>囤钱（hoard money）</strong> 的欲望，因此供应商品的总价值等于需求商品的总价值，这种表述渐渐成为了萨伊定律：供给创造自己的需求（supply creates its own demand），其最重要的观点在于如果供给创造了一个等价值的需求，那么就不会存在生产过剩（over-production）或供过于求（glut）了。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557998258_122199099" alt="1.pnghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557998258_122199099"><br>==over-production，图片来自cdn-images-1.medium.com==<br>对于企业来说，他们可能会错误地估计需求水平，然后过度生产。但奥地利出生的美国经济学家路德维希·冯·米塞斯Ludwig von Mises认为“笨拙的企业家”（“the bungling entrepreneurs”）很快就会被这个市场驱逐出去，而没有被利用的资源将被重新分配给更有利可图的经济领域。所以生产过剩是不会发生的，因为人的欲望远比我们制造商品的能力大得多。<br>萨伊定律便成为了古典经济学家和凯恩斯主义经济学家矛盾冲突的阵地，前者认为供给侧才是经济增长的主要因素，而后者却只将增长与增加需求挂钩。</p><hr><h2 id="2-Why-keep-money？"><a href="#2-Why-keep-money？" class="headerlink" title="2. Why keep money？"></a><strong><em>2. Why keep money？</em></strong></h2><p>凯恩斯在他的著作 <strong><em>《就业、利息和货币通论》（The General Theory of Employment, Interest and Money, 1936）</em></strong> 中抨击了萨伊认为所有的钱都花在购买其他商品上的观点，他指出，人们有时可能会出于一些原因将收入存起来，而不是用来买东西。当人们不用这些钱去进行借贷和投资时，货币流通率降低，需求将最终低于生产价值。这时就会进入到 <strong><em>“需求不足”（“demand deficiency”）</em></strong> 的瓶颈，继而出现失业率的升高。<br>生产过剩真如萨伊所说的不可能存在吗？<br>1929年至1933年，美国经历了四年的<strong>经济大萧条（the Great Depression）</strong>，华尔街股票暴跌产生的疯狂挤兑、银行倒闭、工厂关门、工人失业、内战边缘等连锁反应让美国经济一落千丈。农业资本家和大农场主大量销毁“过剩”的产品，小麦和玉米替煤炭做燃料，牛奶倒进密西西比河。为什么？当时美国生产力不断提高，而人们的工资却一直持续低水平，这就导致了美国生产能力十分过剩的现象。由于供给多，人们想买却限制于自己的工资水平，储存能力又不允许，超低价会引发同行的恶意竞争等问题让人们不得不这样做。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557998351_401716914" alt="2.jpghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557998351_401716914"><br>==In the Great Depression, farm owner poured milk into the Mississippi River，图片来自inews.gtimg.com==<br>当时的失业人口总数达到了830万，在美国各城巿，排队领救济食品的穷人长达几个街区，曾经衣冠楚楚的银行家出现在领取救济面包的队伍中。这样看来，凯恩斯的观点在大萧条时期很有说服力，特别是反驳了萨伊所说的失业只会存在于一些工厂并只持续一小段时间的说法。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557998368_226370678" alt="3.jpghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557998368_226370678"><br>==Free food for the unemployed，图片来自inews.gtimg.com==</p><hr><h2 id="3-Borrowing-or-taxation"><a href="#3-Borrowing-or-taxation" class="headerlink" title="3 . Borrowing or taxation"></a><strong><em>3 . Borrowing or taxation</em></strong></h2><p>政府花销的资金如何筹集？是通过发放政府债券，还是通过税收呢？英国经济学家大卫·李嘉图（David Ricardo）是第一个详细阐明该问题的人。<br>他在 <strong><em>《政治经济学和赋税原理》（Principles of Political Economy and Taxation, 1817）</em></strong> 表明了自己的观点：债券和税收这两种方式没什么不同。赋税者应该意识到，购买政府债券会导致未来更多的税收，而从另一个角度来看，人们会提前预留储蓄以应付以后要支付的税款。人们了解政府的预算限制，无论其决定征税或发放政府债券，其效果都是相同或等价的。人们会把买债券获得的额外收入存起来，此时人们可支配的财富的数量与征税的情况一样，这就是 <strong><em>李嘉图等价（Ricardian equivalence）</em></strong> 。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557998427_120955700" alt="4.jpghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557998427_120955700"><br>==Return the extra money，图片来自dn.sohucs.com==<br>想象一下，一个赌博的父亲向两个儿子一人借了100元，并给了他们每人5%的利息，此时两个儿子的额外收入各为5元。但是父亲告诉儿子们，从他们这里借的钱这个月不会动，因为他已经从朋友Alex那里借到了200元钱。成天逍遥自在、傻呵呵的小儿子把5元钱直接花掉了，而机敏一些的大儿子却意识到，下个月父亲还Alex钱的时候肯定还要交利息，到时候还会管他们要。相当于这额外的5元钱还是会被征收回去。</p><hr><h2 id="4-The-modern-debate"><a href="#4-The-modern-debate" class="headerlink" title="4 . The modern debate"></a><strong><em>4 . The modern debate</em></strong></h2><p>美国经济学家巴罗Robert Barro在他1974年发表的文章中，重提了这一想法，着眼于调查人们不顾及税收和政府债券的情况。<br>如果公众是理性预期的，那么不管是债券融资还是税收融资，政府所采用的融资方式并不会影响经济中的消费、投资、产出和利率水平，具有理性预期的公众明白债券变现最终还是要靠增税来完成，即现期债券相当于未来税收，政府债券融资只不过是移动了增税的时间。因为政府和个人的借贷利率不可能相同，所以这种情况不会发生。<br>而且，人的寿命是有限的，消费者具有“<strong>利他主义</strong>”的遗产动机，尽管发放政府债券具有的减税效应使消费者收入增加，但在理性地预期到将来税收将增加，而子女消费水平将受到不利影响时，消费者就不会因为现期收入的增加而增加消费。消费者不会将政府发行公债融资引起的财政扩张及收入增加看作是幸运的意外收获，他们宁愿将一部分收入储蓄起来以支付未来（甚至子女）的税收负担。<br>巴罗试图通过“李嘉图等价定理”证明财政刺激政策的无效性，激起了整整一代经济学家持续的考察、攻击和验证。1974年那篇论文成为了迄今为止被引用最多的经济学文献之一。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557998472_766823805" alt="5.jpghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557998472_766823805"><br>==哭泣！为财政刺激买单，图片来自larspsyll.files.wordpress.com==</p><hr><h2 id="5-Government-spending"><a href="#5-Government-spending" class="headerlink" title="5 . Government spending"></a><strong><em>5 . Government spending</em></strong></h2><p>李嘉图等价定理有时也被认识为 <strong><em>债务中性（debt neutrality）</em></strong> ，即扩张性的财政政策不会刺激经济扩张，且政府以债券和税收筹资的效果是等价的。这种观点也被新古典经济学家用来反击凯恩斯主义政策：财政支出促进需求和经济增长。他们认为，如果人们知道政府通过财政支出的形式度过萧条，他们的理智会预料到未来更大的税收，所以他们是不会盲目回应的。然而实际证据到底是支持还是反对呢？这一点尚无定论。</p><hr><h2 id="6-Jean-Baptiste-Say"><a href="#6-Jean-Baptiste-Say" class="headerlink" title="6 . Jean-Baptiste Say"></a><strong><em>6 . Jean-Baptiste Say</em></strong></h2><p>今天的内容中我们主要介绍了萨伊和李嘉图的思想，因为后面的内容中我们会继续学习李嘉图的理论知识，所以先来了解一下萨伊。<img src="https://ali.baicizhan.com/readin/images/book_wiki/img_1557998526_174783434" alt="6.jpghttps://ali.baicizhan.com/readin/images/book_wiki/img_1557998526_174783434"><br>==Jean-Baptiste Say，图片来自fee.org==<br>让·巴提斯特·萨伊（Jean-Baptiste Say）出生于一个法国商人家庭，早年开始学习经商，后去英国接受商业教育。在英国他看到了产业革命的发展并接触了斯密的著作。回法国经商的他遇到法国大革命，拥护革命，为革命派撰稿也曾投笔从军。脱离革命后，他完成上文提到的《政治经济学概论》的编写，却因为波旁王朝的复辟，反对关税保护政策被禁，他被迫经商后转为学术研究，撰写了《政治经济学教程》（Complete Course of Practical Political Economy, 1828-1830）。在担任法兰西学院政治经济学教授期间，他把政治经济学思想叙述的通俗而优美。其著作被翻译成多种文字传遍欧洲。很多人是通过萨伊了解斯密和英国古典政治经济学的。<br>但是很多经济学家推崇的“<strong>萨伊定律</strong>”却受到了马克思的批评，他指出萨伊定律的根本错误在于混同了资本流通与简单商品流通，又把简单商品流通归结为物物交换。货币是可以贮藏的，所以总供给并不等于总需求。</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote><p>Great depression：<br><a href="https://en.wikipedia.org/wiki/Great_Depression" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Great_Depression</a><br>Ricardian equivalence：<br><a href="https://en.wikipedia.org/wiki/Ricardian_equivalence" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ricardian_equivalence</a><br>Jean-Baptiste Say：<br><a href="https://en.wikipedia.org/wiki/Jean-Baptiste_Say" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Jean-Baptiste_Say</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-The-impossibility-of-overproduction&quot;&gt;&lt;a href=&quot;#1-The-impossibility-of-overproduction&quot; class=&quot;headerlink&quot; title=&quot;1 . The impossibility of overproduction&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;1 . The impossibility of overproduction&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;斯密在撰写《国富论》时就注意到，商人常常将生意的失败与资金匮乏和生产过剩联系在一起。斯密通过阐述货币在经济中的职能揭穿（debunk）了所谓资金匮乏的真相，而后者则被法国经济学家让·巴提斯特·萨伊（Jean-Baptiste Say）在他的《政治经济学概论》（A Treatise on Political Economy, 1803）中驳回。&lt;/p&gt;
    
    </summary>
    
      <category term="Economic" scheme="http://yoursite.com/categories/Economic/"/>
    
      <category term="Over Production" scheme="http://yoursite.com/categories/Economic/Over-Production/"/>
    
    
      <category term="Economic" scheme="http://yoursite.com/tags/Economic/"/>
    
      <category term="Overproduction" scheme="http://yoursite.com/tags/Overproduction/"/>
    
      <category term="Borrowing" scheme="http://yoursite.com/tags/Borrowing/"/>
    
      <category term="Taxation" scheme="http://yoursite.com/tags/Taxation/"/>
    
  </entry>
  
  <entry>
    <title>tmux 常用命令</title>
    <link href="http://yoursite.com/2019/06/29/tmux/"/>
    <id>http://yoursite.com/2019/06/29/tmux/</id>
    <published>2019-06-29T07:45:26.000Z</published>
    <updated>2019-06-29T08:51:55.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>tmux被称为terminal complexer,作用就是在一个窗口下可以打开多个窗口和切分窗口(叫做panes).<br>层次为3级,从高到低位:session,window和pane.  </p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>tmux允许我们在ssh不稳定的情况下稳定得运行程序.  </p><a id="more"></a><h1 id="简单的命令"><a href="#简单的命令" class="headerlink" title="简单的命令"></a>简单的命令</h1><h2 id="session-level"><a href="#session-level" class="headerlink" title="session-level"></a>session-level</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmux ls                          # list sessions  </span><br><span class="line">tmux new  -s SESSION_NAME        # 创建新的session  </span><br><span class="line">tmux attach -t SESSION_NAME      # 连接session  </span><br><span class="line">tmux detach                      # 从session断开  </span><br><span class="line">tmux rename-session -t OLD_NAME NEW_NAME</span><br></pre></td></tr></table></figure><h2 id="window-level"><a href="#window-level" class="headerlink" title="window-level"></a>window-level</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tmux new-window                   (prefix + c)          # prefix指的是Control+b同时按下后释放,prefix +c意味着Control+b同时按下后释放然后按c    </span><br><span class="line">tmux select-window WINDOW_NAME    (prefix + WINDOW_NUM) # 切换窗口, window_number为1-9的数字   </span><br><span class="line">tmux rename-window                (prefix + ,)          # 重命名窗口  </span><br><span class="line">tmux kill-window -t WINDOW_NAME   (prefix + *)          # 关闭窗口  </span><br><span class="line">```  </span><br><span class="line">## pane-level</span><br></pre></td></tr></table></figure><p>tmux split-window       (prefix + “)           # 把当前window分成上下两个panes<br>tmux split-window -h    (prefix + %)           # 把当前window分成左右两个panes<br>tmux swap-pane -[UDLR]  (prefix + <arrow-key>) # navigate panes<br>tmux kill-pane          (prefix + x)           # kill pane</arrow-key></p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;tmux被称为terminal complexer,作用就是在一个窗口下可以打开多个窗口和切分窗口(叫做panes).&lt;br&gt;层次为3级,从高到低位:session,window和pane.  &lt;/p&gt;
&lt;h1 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h1&gt;&lt;p&gt;tmux允许我们在ssh不稳定的情况下稳定得运行程序.  &lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
      <category term="tmux" scheme="http://yoursite.com/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>scp 用法</title>
    <link href="http://yoursite.com/2019/06/28/scp/"/>
    <id>http://yoursite.com/2019/06/28/scp/</id>
    <published>2019-06-28T07:49:33.000Z</published>
    <updated>2019-06-29T08:52:02.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>linux远程拷贝工具</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>scp [-option] source dest  </p><h2 id="远程连接时文件地址写法"><a href="#远程连接时文件地址写法" class="headerlink" title="远程连接时文件地址写法"></a>远程连接时文件地址写法</h2><p>USER@PATH:FILEPATH</p><a id="more"></a><h2 id="option"><a href="#option" class="headerlink" title="option"></a>option</h2><ul><li>r,文件夹</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h1&gt;&lt;p&gt;linux远程拷贝工具&lt;/p&gt;
&lt;h1 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h1&gt;&lt;p&gt;scp [-option] source dest  &lt;/p&gt;
&lt;h2 id=&quot;远程连接时文件地址写法&quot;&gt;&lt;a href=&quot;#远程连接时文件地址写法&quot; class=&quot;headerlink&quot; title=&quot;远程连接时文件地址写法&quot;&gt;&lt;/a&gt;远程连接时文件地址写法&lt;/h2&gt;&lt;p&gt;USER@PATH:FILEPATH&lt;/p&gt;
    
    </summary>
    
    
      <category term="scp" scheme="http://yoursite.com/tags/scp/"/>
    
  </entry>
  
  <entry>
    <title>supervisor 介绍</title>
    <link href="http://yoursite.com/2019/06/23/supervisor/"/>
    <id>http://yoursite.com/2019/06/23/supervisor/</id>
    <published>2019-06-23T07:45:44.000Z</published>
    <updated>2019-06-29T08:51:13.609Z</updated>
    
    <content type="html"><![CDATA[<p>supervisor是一个进程管理工具,用来启动,停止,重启和监测进程.可以实现诸如检测某个进程,一旦其被杀死就重启的功能.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/03619bf7d7f5" target="_blank" rel="noopener">https://www.jianshu.com/p/03619bf7d7f5</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>sudo pip install supervisor</p></blockquote><a id="more"></a><h2 id="通过echo-supervisord-conf-命令生成配置文件"><a href="#通过echo-supervisord-conf-命令生成配置文件" class="headerlink" title="通过echo_supervisord_conf 命令生成配置文件"></a>通过echo_supervisord_conf 命令生成配置文件</h2><blockquote><p>echo_supervisord_conf &gt; /etc/supervisord.conf</p></blockquote><h2 id="配置文件加入program配置文件的地址"><a href="#配置文件加入program配置文件的地址" class="headerlink" title="配置文件加入program配置文件的地址"></a>配置文件加入program配置文件的地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]  </span><br><span class="line">files = /etc/supervisor/*.conf</span><br></pre></td></tr></table></figure><h2 id="创建program配置文件"><a href="#创建program配置文件" class="headerlink" title="创建program配置文件"></a>创建program配置文件</h2><p>注意把program配置文件放在配置文件中files项下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;a_server.conf</span><br><span class="line"></span><br><span class="line">[program:a_server] ;程序名  </span><br><span class="line">directory = /root/amazon_server ; 程序的启动目录  </span><br><span class="line">command = python app.py  ; 启动命令，可以看出与手动在命令行启动的命令是一样的  </span><br><span class="line">autostart = true     ; 在 supervisord 启动的时候也自动启动  </span><br><span class="line">startsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了  </span><br><span class="line">autorestart = true   ; 程序异常退出后自动重启  </span><br><span class="line">startretries = 3     ; 启动失败自动重试次数，默认是 3   </span><br><span class="line">user = root          ; 用哪个用户启动  </span><br><span class="line">redirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 false  </span><br><span class="line">stdout_logfile_maxbytes = 100MB  ; stdout 日志文件大小，默认 50MB  </span><br><span class="line">stdout_logfile_backups = 10     ; stdout 日志文件备份数  </span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）  </span><br><span class="line">stdout_logfile = /root/amazon_server/app.log  </span><br><span class="line"></span><br><span class="line">killasgroup=true # 使用uwsgi时需要加上</span><br><span class="line">stopasgroup=true # 使用uwsgi时需要加上</span><br></pre></td></tr></table></figure><h2 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h2><blockquote><p>supervisord -c /etc/supervisord.conf</p></blockquote><h2 id="断开现在的配置"><a href="#断开现在的配置" class="headerlink" title="断开现在的配置"></a>断开现在的配置</h2><blockquote><p>unlink /***/supervisor.sock</p></blockquote><h2 id="supervisorctl"><a href="#supervisorctl" class="headerlink" title="supervisorctl"></a>supervisorctl</h2><p>supervisorctl是supervisord的命令行客户端管理工具，用来管理进程  </p><blockquote><p>supervisorctl  # 进入交互shell环境<br>reread         #读取配置文件<br>start a_server #启动程序<br>status         # 查看进程状态<br>exit           # 退出  </p></blockquote><h2 id="开启多个supervisor"><a href="#开启多个supervisor" class="headerlink" title="开启多个supervisor"></a>开启多个supervisor</h2><p>可以通过不同的配置文件来开启多个supervisor,连接方式为</p><blockquote><p>supervisorctl -c 配置文件</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>更新已有文件时需要先stop,然后reread;避免使用reload,因为reload会重启所有服务</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;supervisor是一个进程管理工具,用来启动,停止,重启和监测进程.可以实现诸如检测某个进程,一旦其被杀死就重启的功能.&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/03619bf7d7f5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/03619bf7d7f5&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;sudo pip install supervisor&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
      <category term="supervisor" scheme="http://yoursite.com/tags/supervisor/"/>
    
  </entry>
  
  <entry>
    <title>nohup 用法</title>
    <link href="http://yoursite.com/2019/06/23/nohup/"/>
    <id>http://yoursite.com/2019/06/23/nohup/</id>
    <published>2019-06-23T07:44:53.000Z</published>
    <updated>2019-06-29T10:08:20.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>linux下用来在后台执行程序  </p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>nohup CMD &lt; INPUT &gt; STDOUT 2&gt; STDERR</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>nohup ./xixi.sh &gt; /dev/null 2&gt;&amp;1 &amp;   # /dev/null表示输出到外太空</p><a id="more"></a><h2 id="查看后台运行的程序"><a href="#查看后台运行的程序" class="headerlink" title="查看后台运行的程序"></a>查看后台运行的程序</h2><p>ps -aux # a表示all, u表示按照user, x表示不以终端机来区分</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;p&gt;linux下用来在后台执行程序  &lt;/p&gt;
&lt;h2 id=&quot;指令&quot;&gt;&lt;a href=&quot;#指令&quot; class=&quot;headerlink&quot; title=&quot;指令&quot;&gt;&lt;/a&gt;指令&lt;/h2&gt;&lt;p&gt;nohup CMD &amp;lt; INPUT &amp;gt; STDOUT 2&amp;gt; STDERR&lt;/p&gt;
&lt;h2 id=&quot;举例&quot;&gt;&lt;a href=&quot;#举例&quot; class=&quot;headerlink&quot; title=&quot;举例&quot;&gt;&lt;/a&gt;举例&lt;/h2&gt;&lt;p&gt;nohup ./xixi.sh &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;   # /dev/null表示输出到外太空&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
      <category term="nohup" scheme="http://yoursite.com/tags/nohup/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 锁简介</title>
    <link href="http://yoursite.com/2019/06/23/mysql/"/>
    <id>http://yoursite.com/2019/06/23/mysql/</id>
    <published>2019-06-23T07:44:35.000Z</published>
    <updated>2019-06-29T08:50:26.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql的锁机制"><a href="#mysql的锁机制" class="headerlink" title="mysql的锁机制"></a>mysql的锁机制</h2><p>数据库使用中,除了传统的计算资源(CPU,RAM),不同用户也会共享数据.锁机制就是为了协调多个用户或多个进程/线程并发访问数据,保证数据并发访问的一致性和有效性.<br>每个事务,都可以添加对涉及到的数据的锁.</p><p>按照封锁类型分类,分为排他锁(又叫写锁或X锁)和分享锁(读锁或S锁).  </p><ol><li>排他锁,阻止其它事务对锁作用的数据的读和写;  </li><li>分享锁,阻止其它事务对锁作用的数据的写.  </li></ol><p>按照锁作用的数据的粒度,分为行锁,表锁和页锁.其中页锁比较罕见.<br>1.行锁就是对记录上锁,这是最小的粒度,占用资源最多,允许的并发也最大.<br>试想,你锁了两行数据,其他人还可以对同表的其他行数据操作,但你和其他人可能对这张表上了好几个锁;<br>2.表锁是对数据表上锁,这是最大的粒度,占用资源最少</p><a id="more"></a><h2 id="join相关"><a href="#join相关" class="headerlink" title="join相关"></a>join相关</h2><p>left join： 以左表为主体,基于链接条件补充右表的列<br>right join: 以右表为主体,基于链接条件补充坐表的列<br>inner join: 基于链接条件给出左右表的列<br>inner full join: left join 和 right join的union</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>A表<br>| id | name|<br>| 1 | a |<br>| 2 | beta |</p><p>B表<br>| id | name|<br>| 1 | a |<br>| 2 | b |</p><p>A left join B on A.name=B.name 为<br>| A.id | A.name | B.id | B.name |<br>| 1    |  a     | 1    |  a     |<br>| 2    | beta   | null | null   |</p><p>A right join B on A.name=B.name 为<br>| A.id | A.name | B.id | B.name |<br>| 1    |  a     | 1    |  a     |<br>| null |  null  | 2    |  b     |</p><p>A inner join B on A.name=B.name 为<br>| A.id | A.name | B.id | B.name |<br>| 1    |  a     | 1    |  a     |</p><p>A full outer join B on A.name=B.name 为<br>| A.id | A.name | B.id | B.name |<br>| 1    |  a     | 1    |  a     |<br>| 2    | beta   | null | null   |<br>| null |  null  | 2    |  b     |</p><h2 id><a href="#" class="headerlink" title="@"></a>@</h2><p>@var: 局部变量<br>@@var: 全局变量</p><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><h4 id="分组后按照某个指标选择每组前几名"><a href="#分组后按照某个指标选择每组前几名" class="headerlink" title="分组后按照某个指标选择每组前几名"></a>分组后按照某个指标选择每组前几名</h4><p>按照省来分组,以gdp为指标,选取每个省gdp前十的城市<br>SELECT province, city, gdp, GDP_rank<br>        FROM<br>         (<br>               SELECT province, city, gdp,<br>                @GDP_rank := IF(@current_province = province, @GDP_rank + 1, 1) AS GDP_rank,<br>                @current_province := province<br>            FROM GDP JOIN (SELECT @current_province := NULL, @GDP_rank := 0) AS vars<br>               ORDER BY province, GDP DESC, city<br>         ) ranked<br>         WHERE GDP_rank &lt;= 10;  </p><p> 其中GDP JOIN (SELECT @current_province := NULL, @GDP_rank := 0) AS vars是为了初始化current_province和GDP_rank两个局部变量</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mysql的锁机制&quot;&gt;&lt;a href=&quot;#mysql的锁机制&quot; class=&quot;headerlink&quot; title=&quot;mysql的锁机制&quot;&gt;&lt;/a&gt;mysql的锁机制&lt;/h2&gt;&lt;p&gt;数据库使用中,除了传统的计算资源(CPU,RAM),不同用户也会共享数据.锁机制就是为了协调多个用户或多个进程/线程并发访问数据,保证数据并发访问的一致性和有效性.&lt;br&gt;每个事务,都可以添加对涉及到的数据的锁.&lt;/p&gt;
&lt;p&gt;按照封锁类型分类,分为排他锁(又叫写锁或X锁)和分享锁(读锁或S锁).  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;排他锁,阻止其它事务对锁作用的数据的读和写;  &lt;/li&gt;
&lt;li&gt;分享锁,阻止其它事务对锁作用的数据的写.  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按照锁作用的数据的粒度,分为行锁,表锁和页锁.其中页锁比较罕见.&lt;br&gt;1.行锁就是对记录上锁,这是最小的粒度,占用资源最多,允许的并发也最大.&lt;br&gt;试想,你锁了两行数据,其他人还可以对同表的其他行数据操作,但你和其他人可能对这张表上了好几个锁;&lt;br&gt;2.表锁是对数据表上锁,这是最大的粒度,占用资源最少&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>git之tag</title>
    <link href="http://yoursite.com/2019/06/23/git-tag/"/>
    <id>http://yoursite.com/2019/06/23/git-tag/</id>
    <published>2019-06-23T07:44:15.000Z</published>
    <updated>2019-06-29T08:48:30.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>gitlab/github的tag用来静态得标记版本.比如在branch v0.1开发时,到了某次commit时(比如当前可以作为上线的版本),为了标记当前状态,设置tag v0.1.1.  </p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>git tag -a 0.1.1 -m “Release version 0.1.1”  </p><h2 id="提交到远程服务器"><a href="#提交到远程服务器" class="headerlink" title="提交到远程服务器"></a>提交到远程服务器</h2><p>git push origin –tag  # 全部tags<br>git push origin v0.1.1 # 单个tag</p><a id="more"></a><h2 id="从远程fetch所有tag"><a href="#从远程fetch所有tag" class="headerlink" title="从远程fetch所有tag"></a>从远程fetch所有tag</h2><p>git fetch –tags  </p><h2 id="reset-to某个tag"><a href="#reset-to某个tag" class="headerlink" title="reset to某个tag"></a>reset to某个tag</h2><p>git checkout -b [newBranch] v0.1.1 # 需要创建新分支,因为tag只是一个快照</p><h2 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h2><p>git push origin :refs/tags/v0.1.1  </p><h2 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h2><p>git tag -d v0.1.1  </p><h2 id="查看本地所有tags"><a href="#查看本地所有tags" class="headerlink" title="查看本地所有tags"></a>查看本地所有tags</h2><p>git tag  </p><h2 id="查看某个tag"><a href="#查看某个tag" class="headerlink" title="查看某个tag"></a>查看某个tag</h2><p>git show v0.1.1  </p><h2 id="给指定的commit打tag"><a href="#给指定的commit打tag" class="headerlink" title="给指定的commit打tag"></a>给指定的commit打tag</h2><p>git tag v0.1.1 5ad71e11</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h1&gt;&lt;p&gt;gitlab/github的tag用来静态得标记版本.比如在branch v0.1开发时,到了某次commit时(比如当前可以作为上线的版本),为了标记当前状态,设置tag v0.1.1.  &lt;/p&gt;
&lt;h1 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h1&gt;&lt;h2 id=&quot;打标签&quot;&gt;&lt;a href=&quot;#打标签&quot; class=&quot;headerlink&quot; title=&quot;打标签&quot;&gt;&lt;/a&gt;打标签&lt;/h2&gt;&lt;p&gt;git tag -a 0.1.1 -m “Release version 0.1.1”  &lt;/p&gt;
&lt;h2 id=&quot;提交到远程服务器&quot;&gt;&lt;a href=&quot;#提交到远程服务器&quot; class=&quot;headerlink&quot; title=&quot;提交到远程服务器&quot;&gt;&lt;/a&gt;提交到远程服务器&lt;/h2&gt;&lt;p&gt;git push origin –tag  # 全部tags&lt;br&gt;git push origin v0.1.1 # 单个tag&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 简介</title>
    <link href="http://yoursite.com/2019/06/23/kafka/"/>
    <id>http://yoursite.com/2019/06/23/kafka/</id>
    <published>2019-06-23T07:43:32.000Z</published>
    <updated>2019-06-29T08:50:03.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kafka简介"><a href="#kafka简介" class="headerlink" title="kafka简介"></a>kafka简介</h1><p>kafka是一个实时的分布式的发布-订阅消息系统和数据处理工具.<br>相比传统的消息系统,比如ActiveMQ和RabbitMQ,kafka是分布式的,具有高扩展(分布式天然高扩展),高吞吐量,高可用和贼鸡儿快的特性.</p><h1 id="消息和生产-消费"><a href="#消息和生产-消费" class="headerlink" title="消息和生产/消费"></a>消息和生产/消费</h1><p>消息系统中,消息指的是不同系统之间的通过http,scp等方式传递的数据流.<br>消息有两端,生产端和消费端,两端的主题分别叫生产者和消费者.生产速度比消费速度快很多,会造成消息阻塞,最终系统延时;消费端宕机,则消息丢失.</p><a id="more"></a><h1 id="消息中间件-Message-Broker"><a href="#消息中间件-Message-Broker" class="headerlink" title="消息中间件(Message Broker)"></a>消息中间件(Message Broker)</h1><p>为了避免系统延时和宕机的问题,中间件应运而生,用来解耦消息生产和消息消费.<br>中间件本质上是个持久化储存消息的媒介(存在磁盘),作为消息的集散中心.即使消费者来不及消费,消息也不会丢失.<br>Kafka集群包含一个或多个服务器,这种服务器就叫中间件.</p><h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><p>Topic是kafka中数据的基本单元.<br>kafka中生产者发布带有topic的消息,发给中间件.每个队列对应一个topic.<br>消费者订阅topic,获得对应的消息队列.<br>这样每个消费者对应的消息队列中就只包含自己想要的.<br>每个消费者对应一个offset来记录当前消费的消息位置.即使发生系统宕机,重新恢复后也可以从offset处重新开始.</p><h1 id="Parition和Replica"><a href="#Parition和Replica" class="headerlink" title="Parition和Replica"></a>Parition和Replica</h1><p>Partition是物理上的概念,每个topic分多个分区(partition),分区的编号从0开始.<br>每个分区都有副本(replica),保证partition的高可用性,副本的数量是可以设置的.</p><h1 id="Broker集群"><a href="#Broker集群" class="headerlink" title="Broker集群"></a>Broker集群</h1><p>为了提高可用性和速度,kafka使用中间件集群.<br>分区的副本存在不同的中间价中,每个分区都有一个leader和一个或多个follower.</p><ul><li>leader负责提供读写服务(生产者和消费者只和leader交互),</li><li>follower同步leader数据(也有说消费者可以在follower中进行查询,不确定).</li><li>leader坏了就用follower.</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.hszofficial.site/experiment/2019/04/06/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/" target="_blank" rel="noopener">http://blog.hszofficial.site/experiment/2019/04/06/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</a></p><p><a href="https://www.bilibili.com/video/av37714232/?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av37714232/?p=2</a></p><p><a href="https://zhuanlan.zhihu.com/p/37405836" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37405836</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kafka简介&quot;&gt;&lt;a href=&quot;#kafka简介&quot; class=&quot;headerlink&quot; title=&quot;kafka简介&quot;&gt;&lt;/a&gt;kafka简介&lt;/h1&gt;&lt;p&gt;kafka是一个实时的分布式的发布-订阅消息系统和数据处理工具.&lt;br&gt;相比传统的消息系统,比如ActiveMQ和RabbitMQ,kafka是分布式的,具有高扩展(分布式天然高扩展),高吞吐量,高可用和贼鸡儿快的特性.&lt;/p&gt;
&lt;h1 id=&quot;消息和生产-消费&quot;&gt;&lt;a href=&quot;#消息和生产-消费&quot; class=&quot;headerlink&quot; title=&quot;消息和生产/消费&quot;&gt;&lt;/a&gt;消息和生产/消费&lt;/h1&gt;&lt;p&gt;消息系统中,消息指的是不同系统之间的通过http,scp等方式传递的数据流.&lt;br&gt;消息有两端,生产端和消费端,两端的主题分别叫生产者和消费者.生产速度比消费速度快很多,会造成消息阻塞,最终系统延时;消费端宕机,则消息丢失.&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
      <category term="Producer" scheme="http://yoursite.com/tags/Producer/"/>
    
      <category term="Consumer" scheme="http://yoursite.com/tags/Consumer/"/>
    
      <category term="Broker" scheme="http://yoursite.com/tags/Broker/"/>
    
      <category term="Topic" scheme="http://yoursite.com/tags/Topic/"/>
    
  </entry>
  
  <entry>
    <title>crontab 使用简介</title>
    <link href="http://yoursite.com/2019/06/23/crontab/"/>
    <id>http://yoursite.com/2019/06/23/crontab/</id>
    <published>2019-06-23T07:40:38.000Z</published>
    <updated>2019-06-29T08:49:43.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>cron是一个linux下 的定时执行工具，可以在无需人工干预的情况下运行作业  </p><ul><li>/sbin/service crond start    //启动服务  </li><li>/sbin/service crond stop     //关闭服务  </li><li>/sbin/service crond restart  //重启服务  </li><li>/sbin/service crond reload   //重新载入配置  </li><li>/sbin/service crond status   //查看服务状态   </li></ul><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>minute hour day-of-month month-of-year day-of-week who command</p><a id="more"></a><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>12,24 12 * * * root haha.sh # 以root身份每天12点12分和24分执行haha.sh<br>/2 * * * * * root haha.sh # 每两分钟执行haha.sh  </p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>crontab -e            # 进入用户.cron文件来编辑<br>crontab -l [-u USER]  # 查看用户(默认为当前用户)的文件 </p><h2 id="经典错误"><a href="#经典错误" class="headerlink" title="经典错误"></a>经典错误</h2><p>premature EOF -&gt; 末尾加一空白行</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>crontab xxx.cron # 这条命令会覆盖当前用户的cron文件,不要随便使用</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;cron是一个linux下 的定时执行工具，可以在无需人工干预的情况下运行作业  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/sbin/service crond start    //启动服务  &lt;/li&gt;
&lt;li&gt;/sbin/service crond stop     //关闭服务  &lt;/li&gt;
&lt;li&gt;/sbin/service crond restart  //重启服务  &lt;/li&gt;
&lt;li&gt;/sbin/service crond reload   //重新载入配置  &lt;/li&gt;
&lt;li&gt;/sbin/service crond status   //查看服务状态   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;写法&quot;&gt;&lt;a href=&quot;#写法&quot; class=&quot;headerlink&quot; title=&quot;写法&quot;&gt;&lt;/a&gt;写法&lt;/h2&gt;&lt;p&gt;minute hour day-of-month month-of-year day-of-week who command&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="Crontab" scheme="http://yoursite.com/tags/Crontab/"/>
    
      <category term="Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>npm 全面介绍</title>
    <link href="http://yoursite.com/2019/04/10/npm/"/>
    <id>http://yoursite.com/2019/04/10/npm/</id>
    <published>2019-04-09T19:25:24.000Z</published>
    <updated>2019-06-29T07:39:25.534Z</updated>
    
    <content type="html"><![CDATA[<!-- <img src="http://i1.piimg.com/588926/30e7b49044d5cfc4.png" alt="summary-img-src-npm"> --><a id="more"></a><h1 id="什么是-NPM"><a href="#什么是-NPM" class="headerlink" title="什么是 NPM"></a>什么是 NPM</h1><p>npm 之于 Node.js ，就像 pip 之于 Python， gem 之于 Ruby， pear 之于 PHP 。</p><p>npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p><h1 id="为什么要使用-NPM"><a href="#为什么要使用-NPM" class="headerlink" title="为什么要使用 NPM"></a>为什么要使用 NPM</h1><p>npm 是随同 Node.js 一起安装的包管理工具，能解决 Node.js 代码部署上的很多问题，常见的场景有以下几种：</p><ul><li>允许用户从 npm 服务器下载别人编写的第三方包到本地使用。</li><li>允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。</li><li>允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。</li></ul><p>npm 的背后，是基于 couchdb 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。</p><h1 id="如何使用-NPM"><a href="#如何使用-NPM" class="headerlink" title="如何使用 NPM"></a>如何使用 NPM</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm 不需要单独安装。在安装 Node 的时候，会连带一起安装 npm 。但是，Node 附带的 npm 可能不是最新版本，最后用下面的命令，更新到最新版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install npm@latest -g</span><br></pre></td></tr></table></figure><p>如果是 Window 系统使用以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm -g</span><br></pre></td></tr></table></figure><p>也就是使用 npm 安装自己。之所以可以这样，是因为 npm 本身与 Node 的其他模块没有区别。</p><p>然后，运行下面的命令，查看各种信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 npm 命令列表</span></span><br><span class="line">$ npm <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看各个命令的简单用法</span></span><br><span class="line">$ npm -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 npm 的版本</span></span><br><span class="line">$ npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 npm 的配置</span></span><br><span class="line">$ npm config list -l</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h3><p>npm init 用来初始化生成一个新的 package.json 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。<br>如果使用了 -f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的 package.json 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure><h3 id="npm-set"><a href="#npm-set" class="headerlink" title="npm set"></a>npm set</h3><p>npm set 用来设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">set</span> init-author-name <span class="string">'Your name'</span></span><br><span class="line">$ npm <span class="built_in">set</span> init-author-email <span class="string">'Your email'</span></span><br><span class="line">$ npm <span class="built_in">set</span> init-author-url <span class="string">'http://yourdomain.com'</span></span><br><span class="line">$ npm <span class="built_in">set</span> init-license <span class="string">'MIT'</span></span><br></pre></td></tr></table></figure><p>上面命令等于为 npm init 设置了默认值，以后执行 npm init 的时候，package.json 的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。</p><h3 id="npm-info"><a href="#npm-info" class="headerlink" title="npm info"></a>npm info</h3><p>npm info 命令可以查看每个模块的具体信息。比如，查看 underscore 模块的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm info underscore</span><br></pre></td></tr></table></figure><p>上面命令返回一个 JavaScript 对象，包含了 underscore 模块的详细信息。这个对象的每个成员，都可以直接从 info 命令查询。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm info underscore description</span><br><span class="line"></span><br><span class="line">$ npm info underscore homepage</span><br><span class="line"></span><br><span class="line">$ npm info underscore version</span><br></pre></td></tr></table></figure><h3 id="npm-search"><a href="#npm-search" class="headerlink" title="npm search"></a>npm search</h3><p>npm search 命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm search &lt;搜索词&gt;</span><br></pre></td></tr></table></figure><h3 id="npm-list"><a href="#npm-list" class="headerlink" title="npm list"></a>npm list</h3><p>npm list 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上 global 参数，会列出全局安装的模块</span></span><br><span class="line">$ npm list -global</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm list 命令也可以列出单个模块</span></span><br><span class="line">$ npm list underscore</span><br></pre></td></tr></table></figure><h3 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h3><p>使用 npm 安装包的命令格式为：<br><code>npm [install/i] [package_name]</code></p><h4 id="本地模式和全局模式"><a href="#本地模式和全局模式" class="headerlink" title="本地模式和全局模式"></a>本地模式和全局模式</h4><p>npm 在默认情况下会从 <a href="http://npmjs.org" target="_blank" rel="noopener">http://npmjs.org</a> 搜索或下载包，将包安装到当前目录的 node_modules 子目录下。<br>如果你熟悉 Ruby 的 gem 或者 Python 的 pip，你会发现 npm 与它们的行为不同，gem 或 pip 总是以全局模式安装，使包可以供所有的程序使用，而 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。</p><p>我们在使用 supervisor 的时候使用了 <code>npm install -g supervisor</code> 命令，就是以全局模式安装 supervisor 。</p><p>这里注意一点的就是，supervisor 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 <code>npm config set prefix &quot;路径&quot;</code> 安装完以后就可以用 supervisor 来启动服务了。<br>supervisor 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 Node.js 。</p><p>一般来说，全局安装只适用于工具模块，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为<strong>本地模式不会注册 PATH 环境变量</strong>。“本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。</p><p>本地模式和全局模式的特点如下：</p><table><thead><tr><th align="center">模式</th><th align="center">可通过 require 使用</th><th align="center">注册 PATH</th></tr></thead><tbody><tr><td align="center">本地模式</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">全局模式</td><td align="center">否</td><td align="center">是</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地安装</span></span><br><span class="line">$ npm install &lt;package name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装</span></span><br><span class="line">$ sudo npm install -global &lt;package name&gt;</span><br><span class="line">$ sudo npm install -g &lt;package name&gt;</span><br></pre></td></tr></table></figure><p>npm install 也支持直接输入 Github 代码库地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install git://github.com/package/path.git</span><br><span class="line">$ npm install git://github.com/package/path.git<span class="comment">#0.1.0</span></span><br></pre></td></tr></table></figure><p>安装之前，npm install 会先检查，node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。</p><p>如果你希望，一个模块不管是否安装过， npm 都要强制重新安装，可以使用 -f 或 –force 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &lt;packageName&gt; --force</span><br></pre></td></tr></table></figure><h4 id="安装不同版本"><a href="#安装不同版本" class="headerlink" title="安装不同版本"></a>安装不同版本</h4><p>install 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 @ 和版本号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install sax@latest</span><br><span class="line">$ npm install sax@0.1.1</span><br><span class="line">$ npm install sax@<span class="string">"&gt;=0.1.0 &lt;0.2.0"</span></span><br></pre></td></tr></table></figure><p>install 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 packages.json 文件的哪一项中。</p><blockquote><p>–save：模块名将被添加到 dependencies，可以简化为参数-S。<br>–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install sax --save</span><br><span class="line">$ npm install node-tap --save-dev</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ npm install sax -S</span><br><span class="line">$ npm install node-tap -D</span><br></pre></td></tr></table></figure><h5 id="dependencies-依赖"><a href="#dependencies-依赖" class="headerlink" title="dependencies 依赖"></a>dependencies 依赖</h5><p>这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 <code>markdown-it</code> 这个包，版本是 <code>^8.1.0</code> ，代表最小依赖版本是 <code>8.1.0</code> ，如果这个包有更新，那么当我们使用 npm install 命令的时候，npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"markdown-it"</span>: <span class="string">"^8.1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="devDependencies-开发依赖"><a href="#devDependencies-开发依赖" class="headerlink" title="devDependencies 开发依赖"></a>devDependencies 开发依赖</h5><p>在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"autoprefixer"</span>: <span class="string">"^6.4.0"</span>,<span class="number">0</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>babel-preset-es2015<span class="string">": "</span>^<span class="number">6.0</span><span class="number">.0</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>babel-preset-stage<span class="number">-2</span><span class="string">": "</span>^<span class="number">6.0</span><span class="number">.0</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>babel-register<span class="string">": "</span>^<span class="number">6.0</span><span class="number">.0</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>webpack<span class="string">": "</span>^<span class="number">1.13</span><span class="number">.2</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>webpack-dev-middleware<span class="string">": "</span>^<span class="number">1.8</span><span class="number">.3</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>webpack-hot-middleware<span class="string">": "</span>^<span class="number">2.12</span><span class="number">.2</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>webpack-merge<span class="string">": "</span>^<span class="number">0.14</span><span class="number">.1</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>highlightjs<span class="string">": "</span>^<span class="number">9.8</span><span class="number">.0</span><span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>当你有了一个完整的 package.json 文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 npm install 就可以很方便的下载好这个模块所需要的包。</p><p>npm install 默认会安装 dependencies 字段和 devDependencies 字段中的所有模块，如果使用 –production 参数，可以只安装 dependencies 字段的模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --production</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ NODE_ENV=production npm install</span><br></pre></td></tr></table></figure><p>一旦安装了某个模块，就可以在代码中用 require 命令加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backbone = <span class="built_in">require</span>(<span class="string">'backbone'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(backbone.VERSION)</span><br></pre></td></tr></table></figure><h3 id="npm-run"><a href="#npm-run" class="headerlink" title="npm run"></a>npm run</h3><p>npm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。<br>package.json</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"myproject"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"jshint"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"browserify"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"mocha"</span>: <span class="string">"latest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"jshint **.js"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"mocha test/"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scripts-脚本"><a href="#scripts-脚本" class="headerlink" title="scripts 脚本"></a>scripts 脚本</h4><p>顾名思义，就是一些脚本代码，可以通过 <code>npm run script-key</code> 来调用，例如在这个 package.json 的文件夹下使用 <code>npm run dev</code> 就相当于运行了 <code>node build/dev-server.js</code> 这一段代码。使用 scripts 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。<br>npm run 是 npm run-script 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"node build/dev-server.js"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"node build/build.js"</span>,</span><br><span class="line">    <span class="string">"docs"</span>: <span class="string">"node build/docs.js"</span>,</span><br><span class="line">    <span class="string">"build-docs"</span>: <span class="string">"npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m 'auto-pages' &amp; git push &amp; git checkout master"</span>,</span><br><span class="line">    <span class="string">"build-publish"</span>: <span class="string">"rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push"</span>,</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.vue src"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npm run 如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。<br>npm 内置了两个命令简写， npm test 等同于执行 npm run test，npm start 等同于执行 npm run start。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build"</span>: <span class="string">"npm run build-js &amp;&amp; npm run build-css"</span></span><br></pre></td></tr></table></figure><p>上面的写法是先运行 npm run build-js ，然后再运行 npm run build-css ，两个命令中间用 &amp;&amp; 连接。如果希望两个命令同时平行执行，它们中间可以用 &amp; 连接。</p><p>写在 scripts 属性中的命令，也可以在 node_modules/.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> site/main</span><br><span class="line">browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js</span><br></pre></td></tr></table></figure><p>假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build-js"</span>: <span class="string">"bin/build.sh"</span></span><br></pre></td></tr></table></figure><h3 id="pre-和-post-脚本"><a href="#pre-和-post-脚本" class="headerlink" title="pre- 和 post- 脚本"></a>pre- 和 post- 脚本</h3><p>npm run 为每条命令提供了 pre- 和 post- 两个钩子（hook）。以 npm run lint 为例，执行这条命令之前，npm 会先查看有没有定义 prelint 和 postlint 两个钩子，如果有的话，就会先执行 npm run prelint，然后执行 npm run lint，最后执行 npm run postlint。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"myproject"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"eslint"</span>: <span class="string">"latest"</span></span><br><span class="line">    <span class="string">"karma"</span>: <span class="string">"latest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"eslint --cache --ext .js --ext .jsx src"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"karma start --log-leve=error karma.config.js --single-run=true"</span>,</span><br><span class="line">    <span class="string">"pretest"</span>: <span class="string">"npm run lint"</span>,</span><br><span class="line">    <span class="string">"posttest"</span>: <span class="string">"echo 'Finished running tests'"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个 package.json 文件的例子。如果执行 npm test，会按下面的顺序执行相应的命令。</p><ol><li>pretest</li><li>test</li><li>posttest</li></ol><p>如果执行过程出错，就不会执行排在后面的脚本，即如果 prelint 脚本执行出错，就不会接着执行 lint 和 postlint 脚本。</p><h3 id="npm-bin"><a href="#npm-bin" class="headerlink" title="npm bin"></a>npm bin</h3><p>npm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目根目录下执行</span></span><br><span class="line">$ npm bin</span><br><span class="line">./node_modules/.bin</span><br></pre></td></tr></table></figure><h1 id="创建全局链接"><a href="#创建全局链接" class="headerlink" title="创建全局链接"></a>创建全局链接</h1><p>npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 <code>npm install -g express</code> 安装了 express，这时在工程的目录下运行命令：<br><code>npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express</code><br>我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。<br>除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。</p><h1 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h1><p>包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java、.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。<br>Node.js 的包是一个目录，其中包含了一个 JSON 格式的包说明文件 package.json。严格符合 CommonJS 规范的包应该具备以下特征：<br>。package.json 必须在包的顶层目录下；<br>。二进制文件应该在 bin 目录下；<br>。JavaScript 代码应该在 lib 目录下；<br>。文档应该在 doc 目录下；<br>。单元测试应该在 test 目录下。</p><p>Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。</p><p>我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 package.json，我们可以创建更复杂，更完善，更符合规范的包用于发布。</p><p>Node.js 在调用某个包时，会首先检查包中 packgage.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p><p>package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段：<br><span id="inline-yellow">name</span>: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。<br><span id="inline-blue">description</span>: 包的简要说明。<br><span id="inline-green">version</span>: 符合语义化版本识别规范的版本字符串。<br><span id="inline-red">keywords</span>: 关键字数组，通常用于搜索。<br><span id="inline-purple">maintainers</span>: 维护者数组，每个元素要包含 name 、email(可选)、web(可选)字段。<br><span id="inline-yellow">contributors</span>: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。<br><span id="inline-blue">bugs</span>: 提交 bug 的地址，可以是网址或者电子邮件地址。<br><span id="inline-green">licenses</span>: 许可证数组，每个元素要包含 type（许可证的名称）和 url（链接到许可证文本的地址）字段。<br><span id="inline-red">repositories</span>: 仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。<br><span id="inline-purple">dependencies</span>: 包的依赖，一个关联数组，由包名称和版本号组成。</p><h1 id="包的发布"><a href="#包的发布" class="headerlink" title="包的发布"></a>包的发布</h1><p>通过使用 npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个 index.js 作为包的接口,一个简单的包就制作完成了。<br>在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 npm adduser 根据提示完成账号的创建<br>完成后可以使用 npm whoami 检测是否已经取得了账号。<br>接下来,在 package.json 所在目录下运行 npm publish，稍等片刻就可以完成发布了，打开浏览器，访问 <a href="http://search.npmjs.org/" target="_blank" rel="noopener">http://search.npmjs.org/</a> 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install neveryumodule 命令来安装它。<br>如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段,然后重新使用 npm publish 命令就行了。<br>如果你对已发布的包不满意，可以使用 npm unpublish 命令来取消发布。</p><p id="div-border-top-yellow">*需要说明的是：json 文件不能有注释*</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://javascript.ruanyifeng.com/nodejs/npm.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/npm.html</a></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>npm version  查看npm和node的版本<br>npm list –depth=0 [-g]  查看[全局]安装的包<br>npm root [-g]  查看[全局的]包的安装路径</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;img src=&quot;http://i1.piimg.com/588926/30e7b49044d5cfc4.png&quot; alt=&quot;summary-img-src-npm&quot;&gt; --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Git 学习总结</title>
    <link href="http://yoursite.com/2018/10/07/git/"/>
    <id>http://yoursite.com/2018/10/07/git/</id>
    <published>2018-10-07T05:25:24.000Z</published>
    <updated>2019-06-29T08:49:52.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-简介"><a href="#git-简介" class="headerlink" title="git 简介"></a>git 简介</h2><p>git 是分布式的，所以其核心就是分支，分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到 master 分支，master 分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。<br>在 git 中，工作目录下面的所有文件都不外乎这两种状态：<strong>已跟踪</strong>或<strong>未跟踪</strong>。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p><a id="more"></a><h2 id="实用指令详解"><a href="#实用指令详解" class="headerlink" title="实用指令详解"></a>实用指令详解</h2><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>通常，合并分支时，如果可能，Git 会用 Fast froward 模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用 Fast forward 模式，Git 就会在 merge 时生成一个新的 commit ，这样，从分支历史上就可以看出分支信息。<br><code>git merge --no-ff -m &#39;merge  with no-ff&#39; dev</code><br>因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。</p><p>合并分支时，加上 <code>--no-ff</code> 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。</p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>一旦远程主机的版本库有了更新(git 术语叫做 commit)，需要将这些更新取回本地，这时就要用到 git fetch 命令。<br><code>git fetch &lt;远程主机名&gt;</code><br>上面命令将某个远程主机的更新，全部取回本地。<br>默认情况下，git fetch 取回所有分支(branch)的更新。如果只想取回特定分支的更新，可以指定分支名。<br><code>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code><br>比如，取回 origin 主机的 master 分支<br><code>git fetch origin master</code><br>所取回的更新，在本地主机上要用“远程主机名/分支名”的形式读取。比如 origin 主机的 master，就要用 origin/master 读取。</p><p><code>git fetch -p</code> ：取回远程更新，删除不存在的分支。</p><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>git pull 命令的作用是，取回远程主机的某个分支的更新，再与本地的指定分支合并，完整格式如下：<br><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code><br>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。<br><code>git pull origin next:master</code><br>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。<br><code>git pull origin master</code><br>上面的命令表示，取回 origin/master 分支，再与当前分支合并。实质上，这等同于先做 git fetch，再 merge。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p>在某些场合，git 会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在 git clone 的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的 master 分支自动“追踪” origin/master 分支。<br>git 也允许手动建立追踪关系。<br><code>git branch --set-upstream master origin/next</code><br>上面的命令指定 master 分支追踪 origin/next 分支。<br>如果当前分支与远程分支存在追踪关系，git pull 就可以省略远程分支名。<br><code>git pull origin</code><br>上面命令表示，本地的当前分支自动与对应的 origin 主机“追踪分支”(remote-tracking branch)进行合并。<br>如果当前分支只有一个追踪分支，连远程主机名都可以忽略。<br><code>git pull</code><br>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。<br>如果合并需要采用 rebase 模式，可以使用 -rebase 选项。<br><code>git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>git push 命令用于将本地分支的更新，推送到远程主机。它的格式与 git pull 命令相仿。<br><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><br>如果省略远程分支名，则表示将本地分支推送与之存在“追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。<br><code>git push origin master</code><br>上面命令表示，将本地的 master 分支推送到 origin 主机的 master 分支。如果后者不存在，则会被新建。<br><strong>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</strong><br><code>git push origin :master</code><br>等同于<br><code>git push origin --delete master</code><br>上面命令表示删除 origin 主机的 master 分支。<br>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。<br><code>git push origin</code><br>上面命令表示，将当前分支推送到 origin 主机的对应分支。<br>如果当前分支只有一个追踪分支，那么主机名都可以省略。<br><code>git push</code><br>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用 git push 。<br><code>git push -u origin master</code><br>上面的命令将本地 master 分支推送到 origin 主机，同时指定 origin 为默认主机，后面就可以不加任何参数使用 git push 了。<br>不带任何参数的 git push ，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。<br>git 2.0 版本之前，默认采用 matching 方式，现在改为默认采用 simple 方式，如果要修改这个设置，可以采用 git config 命令。<br><code>git config --global push.default matching</code><br>或者<br><code>git config --global push.default simple</code><br>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 -all 选项。<br><code>git push --all origin</code><br>上面命令表示，将所有本地分支都推送到 origin 主机。<br>如果远程主机的版本比本地版本更新，推送时 git 会报错，要求先在本地做 git pull 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 -force 选项。<br><code>git push --force origin</code><br>上面命令使用-force选项，结果导致在远程主机产生一个“非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用 -force 选项。<br>最后，git push 不会推送标签(tag)，除非使用 -tags 选项。<br><code>git push origin --tags</code></p><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p><code>git log</code> 命令可以查看历史记录，<code>git log</code> 命令显示从最近到最远的提交日志；<br>如果嫌输出信息太多，看得眼花缭乱的，可以试试 <code>git log --pretty=oneline</code> 。我们可以看到当前版本以及之前的版本日志以及版本号。<br>用 <code>git log --graph</code> 命令可以看到分支合并图。<br>或者两个参数一起用：<br><code>git log --graph --pretty=oneline</code><br><code>git log --graph --pretty=oneline --abbrev-commit</code><br>首先，git 必须知道当前版本是哪个版本，在 git 中，用 HEAD 表示当前版本，上一个版本就是 <code>HEAD^</code> ，上上一个版本就是 <code>HEAD^^</code> ， 当然往上100个版本写100个 <code>^</code> 比较容易数不过来，所以写成 <code>HEAD~100</code> 。<br>现在，我们要把当前版本回退到上一个版本，就可以使用 <code>git reset</code> 命令：<br><code>git reset --hard HEAD^</code><br>当你回退到了某个版本后，<code>git log</code> 只能显示此版本及之前的版本的日志，之后的版本日志就看不到了，但是，我们想恢复到之后教新的版本怎么办？<br>Git 提供了一个命令 <code>git reflog</code> 用来记录你的每一次命令</p><h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>查看标签（用来标记标志性的稳定版本信息）<br>发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>相比于 commit 的版本号(40位16进制)，标签号则要好使的多。<br>所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑定在一起。</p><p><code>git tag [tag name]</code><br>如果没有标签名，则为查看所有标签，带标签名则为新建标签</p><p><code>git tag &lt;tag name&gt;</code> 就可以打一个新标签</p><p>还可以创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字。<br><code>git tag -a &lt;tag name&gt; -m &lt;comment&gt;</code> ：添加带注释的标签<br>eg: <code>git tag -a v1.2 -m &#39;version 1.2 released&#39;</code></p><p><code>git tag -a &lt;tag name&gt; &lt;md5&gt;</code> ：对某个版本打标签<br>默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？<br>方法是找到历史提交的 commit id，然后打上就可以了。<br><code>git log --pretty=oneline --abbrev-commit</code><br>比方说要对 add merge 这次提交打标签，它对应的 commit id 是 6224937，那么我们就可以使用命令：<br><code>git tag v1.2 6224937</code><br>再用命令 <code>git log</code> 查看标签</p><p>可以用 <code>git show &lt;tagname&gt;</code> 查看标签信息</p><p>如果标签打错了，也可以删除：<br><code>git tag -d v1.2</code></p><p>如果要推送某个标签到远程，使用命令 <code>git push origin &lt;tagname&gt;</code><br>eg: <code>git push origin v1.2</code></p><p>如果标签已经推送到远程，要删除远程标签就要麻烦一点，先从本地删除：<br><code>git tag -d v1.2</code><br>然后，从远程删除；删除命令也是 push ，但是格式如下：<br><code>git push origin :ref/tags/v1.2</code></p><p><code>git tag -l &#39;[expression]&#39;</code><br>查看那符合正则表达式的</p><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p><code>git stash</code><br>备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。<br><code>git stash pop</code><br>从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。<br><code>git stash list</code><br>显示 Git 栈中内的所有备份，可以利用这个列表来决定从哪个地方恢复。<br><code>git stash clear</code> : 清空 Git 栈。</p><p>使用 git 的时候，我们往往使用 branch 解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码，如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码 commit 提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 bug，那么使用 git stash 就可以将你当前未提交到本地的代码推入到 git 的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 bug，等到修完 bug，提交到服务器上后，再使用 git stash apply 将以前一般的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用 git stash 命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑， git stash list 命令可以将当前的 Git 栈信息打印出来，你只需要将找到对应的版本号，例如使用 <code>git stash apply stash@{1}</code> 就可以将你指定版本号为 stash@{1} 的工作取出来，当你将所有的栈都应用回来的时候，可以使用 git stash clear 来将栈清空。<br>在这里顺便提下 git format-patch -n , n是具体某个数字， 例如 ‘git format-patch -1’ 这时便会根据log生成一个对应的补丁，如果 ‘git format-patch -2’ 那么便会生成 2 个补丁，当然前提是你的 log 上有至少有两个记录。</p><p>看过上面的信息，就可以知道使用场合了：当前工作区内容已被修改，但是并未完成。这时 Boss 来了，说前面的分支上面有一个 bug，需要立即修复。可是我又不想提交目前的修改，因为修改没有完成。但是，不提交的话，又没有办法 checkout 到前面的分支。此时用 git stash 就相当于备份了工作区了。然后在 checkout 过去修改，就能够达到保存当前工作区，并及时恢复的作用。</p><p>注意这里由于只 stash 了一次所以要使用 pop，具体你存放了多少。</p><h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><p>查看远程仓库名</p><p><code>git remote -v</code><br>查看远程仓库url</p><p><code>git remote add &lt;basename&gt; &lt;url&gt;</code><br>新增远程仓库</p><p><code>git remote show &lt;basename&gt;</code><br>查看远程仓库详细信息</p><p><code>git remote rename &lt;old basename&gt; &lt;new basename&gt;</code><br>重命名远程仓库</p><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p><code>git commit -a -m &#39;xx&#39;</code><br>暂存并提交</p><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><p><code>git branch</code><br>查看本地仓库分支</p><p><code>git branch -r</code><br>查看远程分支情况</p><p><code>git branch -a</code><br>查看本地和远程的所有分支情况</p><p><code>git branch -v</code><br>查看本地仓库分支最后一次提交情况</p><p><code>git branch -vv</code><br>查看分支跟踪情况</p><p><code>git branch &lt;branch name&gt;</code><br>新建分支</p><p><code>git branch -d &lt;branch name&gt;</code><br>删除分支</p><p><code>git branch -D &lt;branch name&gt;</code><br>强制删除分支</p><p><code>git branch [--merged | --no-merged]</code><br>查看已合并|未合并的本地仓库分支</p><p><code>git branch -u &lt;remote base&gt;/&lt;remote branch&gt;</code><br>修改当前跟踪分支</p><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><p><code>git checkout -- [file]</code> ：恢复文件<br><code>git checkout -- demo.html</code> 意思就是，把 <code>demo.html</code> 文件在工作区的修改全部撤销，这里有两种情况：<br>一种是 <code>demo.html</code> 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是 <code>demo.html</code> 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加暂存区后的状态。<br>总之，就是让这个文件回到最后一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p><p>但是如果 <code>git add</code> 到暂存区了，在 commit 之前，想撤销：<br>Git 同样告诉我们，用命令 <code>git reset HEAD file</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。<br><code>git reset</code> 命令既可以回退版本，也可以把暂存区的修改回退到工作区，当我们用 <code>HEAD</code> 时，表示最新的版本。<br>再用 <code>git status</code> 查看一下，现在暂存区是干净的，工作区有修改：<br>还记得如果丢弃工作区的修改吗？<br>对的，使用：<code>git checkout -- demo.html</code> </p><p><code>git checkout</code> 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。</p><p><code>git checkout -b [branchname] [tagname]</code><br>在特定的版本上创建一个新的分支并切换到此分支</p><p><code>git checkout -b [local branch] [remote base]/[remote branch]</code><br>将远程分支检出到本地分支，并追踪</p><p><code>git checkout --track &lt;remote base&gt;/&lt;remote branch&gt;</code><br>让当前分支跟踪远程分支</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p><code>git rebase [basebranch]</code><br>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>git clone 支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等。<br>使用 https 除了速度慢意外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。</p><p><code>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code><br>如果不写本地目录名，默认就是版本库的名字</p><h3 id="如何新建分支"><a href="#如何新建分支" class="headerlink" title="如何新建分支"></a>如何新建分支</h3><p>本地建立 branch 並立即切换到新分支<br><code>git checkout -b &lt;branch_name&gt;</code> </p><p>下面的命令表示，在 <code>origin/master</code> 的基础上，创建一个分支。<br><code>git checkout -b newBranch origin/master</code></p><p>修改分支名称<br><code>git branch -m &lt;new_name&gt;</code></p><h3 id="从远程仓库拉取代码到本地仓库，并建立跟踪关系"><a href="#从远程仓库拉取代码到本地仓库，并建立跟踪关系" class="headerlink" title="从远程仓库拉取代码到本地仓库，并建立跟踪关系"></a>从远程仓库拉取代码到本地仓库，并建立跟踪关系</h3><p><code>git checkout -b &lt;本地新分支名&gt; &lt;对应的远程分支名&gt;</code></p><h3 id="如何在远程仓库新建一个分支"><a href="#如何在远程仓库新建一个分支" class="headerlink" title="如何在远程仓库新建一个分支"></a>如何在远程仓库新建一个分支</h3><p>新建一个本地分支，按照正常流程提交完代码后，推送到远程<br><code>git push &lt;remote base&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code></p><h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><p><code>git diff HEAD -- demo.html</code><br>命令可以查看工作区的 demo.html 和版本库里面最新版本的区别。</p><h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><p>默认方法是在当前项目目录下创建一个 .gitignore 文件，如果需要忽略的文件已经添加到版本库中，请先移除<br><code>git rm --cached [file]</code><br>不删除文件，只移除追踪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat .gitignore</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure><p>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以注释符号 # 开头的目录都会被 git 忽略</li><li>可以使用标准的 glob 模式匹配</li><li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反</li></ul><h3 id="bug-分支"><a href="#bug-分支" class="headerlink" title="bug 分支"></a>bug 分支</h3><p>git 提供了一个 stash 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。<br><code>git stash</code><br>修改完 bug 后，回到当前分支上继续干活，工作区是干净的，刚才的工作现场存到哪里去了？<br><code>git stash list</code> ：查看 stash 列表(stash 是一个栈的结构)<br>git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法：<br>一是用 <code>git stash apply</code> 恢复，但是恢复后，stash 内容并不删除，你需要用 <code>git stash drop</code> 来删除；<br>另一种方式是用 <code>git stash pop</code> ，恢复的同时把 stash 内容也删了；<br>你可以多次 stash ，恢复的时候，先用 <code>git stash list</code> 查看，然后恢复指定的 stash，用命令：<br><code>git stash apply stash@{0}</code></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置 Git 的时候，加上 –global 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。<br>配置文件放哪了？<br>每个仓库的 Git 配置文件都放在 .git/config 文件中，在这份配置文件中，别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。</p><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><p><code>git config -1</code></p><h3 id="设置git-push-默认"><a href="#设置git-push-默认" class="headerlink" title="设置git push 默认"></a>设置git push 默认</h3><p><code>git config --global push.default current</code></p><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p><code>git config --global alias.&lt;name&gt; &lt;commend&gt;</code><br>我的设置：<br><code>git config --global alias.st status</code><br><code>git config --global alias.cm &quot;commit -m&quot;</code><br><code>git config --global alias.ph &quot;push origin &lt;local_repository&gt;:&lt;remote_repository&gt;&quot;</code></p><h3 id="保存用户名和密码"><a href="#保存用户名和密码" class="headerlink" title="保存用户名和密码"></a>保存用户名和密码</h3><h4 id="对于http-s-协议，可以用下面命令临时缓存"><a href="#对于http-s-协议，可以用下面命令临时缓存" class="headerlink" title="对于http(s)协议，可以用下面命令临时缓存"></a>对于http(s)协议，可以用下面命令临时缓存</h4><p><code>git config --global credential.helper cache</code><br>开启linux缓存<br><code>git config --global credential.helper wincred</code><br>开启windows缓存</p><h4 id="对于-ssh-协议，可以用-ssh-key，具体教程网上很多"><a href="#对于-ssh-协议，可以用-ssh-key，具体教程网上很多" class="headerlink" title="对于 ssh 协议，可以用 ssh key，具体教程网上很多"></a>对于 ssh 协议，可以用 ssh key，具体教程网上很多</h4><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>git 中执行命令 <code>add .</code><br>报错：Unlink of file ‘templates/opms.exe’ failed.Should I try again?(y/n)</p><p>因为这个文件正在被占用，所以不能添加到暂存区，而正好这个 <code>.exe</code> 文件，我们是不需要添加到版本管理工具的。所以我们选择 <code>n</code> 。</p><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>git 中生成 sshkey: <code>ssh-keygen -t rsa -C &quot;youremail&quot;</code><br>这个<code>email</code>并没有什么用<br>所以我们使用<code>ssh-keygen -t rsa</code>来生成sshkey就可以了。<br>然后git中的配置文件：<br><code>git config --list</code><br><code>git config --global user.name &quot;yu&quot;</code><br><code>git config --global user.email &quot;react.dong.yu@gmail.com&quot;</code><br>这种配置将会对本地所有的git仓库有效。<br>那么在 push 的时候，远程就知道这个push来自于哪个email.<br>但有时候在公司的时候，有的仓库是公司的，有的仓库是自己github的。<br>这个时候就可以不设置global的配置了，而是在自己的仓库中设置<br><code>git config --local user.email &quot;react.dong.yu@gmail.com&quot;</code></p><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>使用 windows 的同学注意了，如果你在资源管理器里新建一个 .gitignore 文件，它会提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 .gitignore 了。<br>有些时候，你想添加一个文件到 git，但发现添加不了，原因是这个文件被 .gitignore 忽略了：<br><code>git add App.class</code><br>如果你确实想添加该文件，可以用 -f 制添加到 git：<br><code>git add -f App.class</code><br>或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了。<br>可以用 <code>git check-ignore</code> 命令检查：<br><code>git check-ignore -v App.class</code></p><h3 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h3><p>为什么我把我生成的 ssh key 添加到了 github 中<br>然后 也 remote 了 <code>https://github.com/Neveryu/Xxx.git</code><br>为什么提交的时候报错，或者提示 输入密码账号是为什么</p><p>ssh key 是 ssh 协议的密钥，http 协议没权限</p><h3 id="问题五"><a href="#问题五" class="headerlink" title="问题五"></a>问题五</h3><p>git怎样删除未监视的文件 untracked files?<br>用 git clean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 删除 untracked files</span><br><span class="line">git clean -f</span><br><span class="line"> </span><br><span class="line"># 连 untracked 的目录也一起删掉</span><br><span class="line">git clean -fd</span><br><span class="line"> </span><br><span class="line"># 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）</span><br><span class="line">git clean -xfd</span><br><span class="line"> </span><br><span class="line"># 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删</span><br><span class="line">git clean -nxfd</span><br><span class="line">git clean -nf</span><br><span class="line">git clean -nfd</span><br></pre></td></tr></table></figure><h2 id="我的常用命令"><a href="#我的常用命令" class="headerlink" title="我的常用命令"></a>我的常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -avv</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p><a href="http://git-scm.com/book/zh/v2" target="_blank" rel="noopener">权威教程</a><br><a href="http://iissnan.com/progit/" target="_blank" rel="noopener">Pro Git 简体中文版</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git-简介&quot;&gt;&lt;a href=&quot;#git-简介&quot; class=&quot;headerlink&quot; title=&quot;git 简介&quot;&gt;&lt;/a&gt;git 简介&lt;/h2&gt;&lt;p&gt;git 是分布式的，所以其核心就是分支，分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到 master 分支，master 分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。&lt;br&gt;在 git 中，工作目录下面的所有文件都不外乎这两种状态：&lt;strong&gt;已跟踪&lt;/strong&gt;或&lt;strong&gt;未跟踪&lt;/strong&gt;。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。&lt;/p&gt;
    
    </summary>
    
      <category term="综合" scheme="http://yoursite.com/categories/%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Markdown</title>
    <link href="http://yoursite.com/2018/05/12/markdown/"/>
    <id>http://yoursite.com/2018/05/12/markdown/</id>
    <published>2018-05-12T07:06:50.000Z</published>
    <updated>2019-06-29T08:48:47.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><blockquote><h4 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown<em>是什么</em>？</h4><h4 id="谁创造了它？"><a href="#谁创造了它？" class="headerlink" title="谁创造了它？"></a><em>谁</em>创造了它？</h4><h4 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a><em>为什么</em>要使用它？</h4><h4 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a><em>怎么</em>使用？</h4><h4 id="谁在用？"><a href="#谁在用？" class="headerlink" title="谁在用？"></a><em>谁</em>在用？</h4><h4 id="尝试一下"><a href="#尝试一下" class="headerlink" title="尝试一下"></a>尝试一下</h4></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Markdown是什么？"><a href="#1-Markdown是什么？" class="headerlink" title="1. Markdown是什么？"></a>1. Markdown<em>是什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。    </p><a id="more"></a><h3 id="2-谁创造了它？"><a href="#2-谁创造了它？" class="headerlink" title="2. 谁创造了它？"></a>2. <em>谁</em>创造了它？</h3><p>它由<a href="http://www.aaronsw.com/" target="_blank" rel="noopener"><strong>Aaron Swartz</strong></a>和<strong>John Gruber</strong>共同设计，<strong>Aaron Swartz</strong>就是那位于去年（<em>2013年1月11日</em>）自杀,有着<strong>开挂</strong>一般人生经历的程序员。维基百科对他的<a href="http://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="noopener">介绍</a>是：<strong>软件工程师、作家、政治组织者、互联网活动家、维基百科人</strong>。    </p><p>他有着足以让你跪拜的人生经历：    </p><ul><li><strong>14岁</strong>参与RSS 1.0规格标准的制订。     </li><li><strong>2004</strong>年入读<strong>斯坦福</strong>，之后退学。   </li><li><strong>2005</strong>年创建<a href="http://infogami.org/" target="_blank" rel="noopener">Infogami</a>，之后与<a href="http://www.reddit.com/" target="_blank" rel="noopener">Reddit</a>合并成为其合伙人。   </li><li><strong>2010</strong>年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。   </li><li><strong>2011</strong>年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。     </li><li><strong>2013</strong>年1月自杀身亡。    </li></ul><p><img src="https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg" alt="Aaron Swartz"></p><p>天才都有早逝的归途。</p><h3 id="3-为什么要使用它？"><a href="#3-为什么要使用它？" class="headerlink" title="3. 为什么要使用它？"></a>3. <em>为什么</em>要使用它？</h3><ul><li>它是易读（看起来舒服）、易写（语法简单）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li><li>兼容HTML，可以转换为HTML格式发布。</li><li>跨平台使用。</li><li>越来越多的网站支持Markdown。</li><li>更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）</li><li>摆脱Word（我不是认真的）。</li></ul><h3 id="4-怎么使用？"><a href="#4-怎么使用？" class="headerlink" title="4. 怎么使用？"></a>4. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p><p>Markdown语法主要分为如下几大部分：<br><strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\</code></strong>，<strong>符号’`’</strong>。</p><h4 id="4-1-标题"><a href="#4-1-标题" class="headerlink" title="4.1 标题"></a>4.1 标题</h4><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p><blockquote><p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p></blockquote><p>效果：</p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题   "></a>一级标题   </h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p>2）使用<code>#</code>，可表示1-6级标题。</p><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题    </p></blockquote><p>效果：</p><blockquote><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h4 id="4-2-段落"><a href="#4-2-段落" class="headerlink" title="4.2 段落"></a>4.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p><h4 id="4-3-区块引用"><a href="#4-3-区块引用" class="headerlink" title="4.3 区块引用"></a>4.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>&gt; 区块引用<br>&gt;&gt; 嵌套引用  </p></blockquote><p>效果：</p><blockquote><p>区块引用  </p><blockquote><p>嵌套引用</p></blockquote></blockquote><h4 id="4-4-代码区块"><a href="#4-4-代码区块" class="headerlink" title="4.4 代码区块"></a>4.4 代码区块</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p><p>void main()<br>{        printf(“Hello, Markdown.”);<br>}    </p><p>代码区块：</p><pre><code>void main(){    printf(&quot;Hello, Markdown.&quot;);}</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p><h4 id="4-5-强调"><a href="#4-5-强调" class="headerlink" title="4.5 强调"></a>4.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p>*斜体*，_斜体_<br>**粗体**，__粗体__</p></blockquote><p>效果：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><h4 id="4-6-列表"><a href="#4-6-列表" class="headerlink" title="4.6 列表"></a>4.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p><blockquote><p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p></blockquote><p><strong>注意</strong>：标记后面最少有一个_空格<em>或</em>制表符_。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p><blockquote><p>1 . 第一项<br>2 . 第二项<br>3 . 第三项    </p></blockquote><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><h4 id="4-7-分割线"><a href="#4-7-分割线" class="headerlink" title="4.7 分割线"></a>4.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><h4 id="4-8-链接"><a href="#4-8-链接" class="headerlink" title="4.8 链接"></a>4.8 链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。    <strong>行内式</strong>：</p><blockquote><p>[younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。</p></blockquote><p>效果：</p><blockquote><p><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库</a>。</p></blockquote><p><strong>参考式</strong>：</p><blockquote><p>[younghz的Markdown库1][1]<br>[younghz的Markdown库2][2]<br>[1]:https:://github.com/younghz/Markdown “Markdown”<br>[2]:https:://github.com/younghz/Markdown “Markdown”    </p></blockquote><p>效果：</p><blockquote><p><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库1</a><br><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库2</a></p></blockquote><p><strong>注意</strong>：上述的<code>[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;</code>不出现在区块中。</p><h4 id="4-9-图片"><a href="#4-9-图片" class="headerlink" title="4.9 图片"></a>4.9 图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p><h4 id="4-10-反斜杠"><a href="#4-10-反斜杠" class="headerlink" title="4.10 反斜杠\"></a>4.10 反斜杠<code>\</code></h4><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p><h4 id="4-11-符号’-’"><a href="#4-11-符号’-’" class="headerlink" title="4.11 符号’`’"></a>4.11 符号’`’</h4><p>起到标记作用。如：</p><blockquote><p>`ctrl+a`</p></blockquote><p>效果：</p><blockquote><p><code>ctrl+a</code>    </p></blockquote><h4 id="5-谁在用？"><a href="#5-谁在用？" class="headerlink" title="5. 谁在用？"></a>5. <em>谁</em>在用？</h4><p>Markdown的使用者：</p><ul><li>GitHub</li><li>简书</li><li>Stack Overflow</li><li>Apollo</li><li>Moodle</li><li>Reddit</li><li>等等</li></ul><h4 id="6-尝试一下"><a href="#6-尝试一下" class="headerlink" title="6. 尝试一下"></a>6. 尝试一下</h4><ul><li><strong>Chrome</strong>下的插件诸如<code>stackedit</code>与<code>markdown-here</code>等非常方便，也不用担心平台受限。</li><li><strong>在线</strong>的dillinger.io评价也不错   </li><li><strong>Windowns</strong>下的MarkdownPad也用过，不过免费版的体验不是很好。    </li><li><strong>Mac</strong>下的Mou是国人贡献的，口碑很好。</li><li><strong>Linux</strong>下的ReText不错。    </li></ul><p><strong>当然，最终境界永远都是笔下是语法，心中格式化 :)。</strong></p><hr><p><strong>注意</strong>：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。<br>虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber]<br>(<a href="http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/" target="_blank" rel="noopener">http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/</a> )。</p><hr><p>以上基本是所有traditonal markdown的语法。</p><h3 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h3><p>列表的使用(非traditonal markdown)：</p><p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p><table><thead><tr><th align="center">代码库</th><th>链接</th></tr></thead><tbody><tr><td align="center">MarkDown</td><td><a href="https://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></td></tr><tr><td align="center">MarkDownCopy</td><td><a href="https://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></td></tr></tbody></table><p>关于其它扩展语法可参见具体工具的使用说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;Markdown是什么？&quot;&gt;&lt;a href=&quot;#Markdown是什么？&quot; class=&quot;headerlink&quot; title=&quot;Markdown是什么？&quot;&gt;&lt;/a&gt;Markdown&lt;em&gt;是什么&lt;/em&gt;？&lt;/h4&gt;&lt;h4 id=&quot;谁创造了它？&quot;&gt;&lt;a href=&quot;#谁创造了它？&quot; class=&quot;headerlink&quot; title=&quot;谁创造了它？&quot;&gt;&lt;/a&gt;&lt;em&gt;谁&lt;/em&gt;创造了它？&lt;/h4&gt;&lt;h4 id=&quot;为什么要使用它？&quot;&gt;&lt;a href=&quot;#为什么要使用它？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用它？&quot;&gt;&lt;/a&gt;&lt;em&gt;为什么&lt;/em&gt;要使用它？&lt;/h4&gt;&lt;h4 id=&quot;怎么使用？&quot;&gt;&lt;a href=&quot;#怎么使用？&quot; class=&quot;headerlink&quot; title=&quot;怎么使用？&quot;&gt;&lt;/a&gt;&lt;em&gt;怎么&lt;/em&gt;使用？&lt;/h4&gt;&lt;h4 id=&quot;谁在用？&quot;&gt;&lt;a href=&quot;#谁在用？&quot; class=&quot;headerlink&quot; title=&quot;谁在用？&quot;&gt;&lt;/a&gt;&lt;em&gt;谁&lt;/em&gt;在用？&lt;/h4&gt;&lt;h4 id=&quot;尝试一下&quot;&gt;&lt;a href=&quot;#尝试一下&quot; class=&quot;headerlink&quot; title=&quot;尝试一下&quot;&gt;&lt;/a&gt;尝试一下&lt;/h4&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;h3 id=&quot;1-Markdown是什么？&quot;&gt;&lt;a href=&quot;#1-Markdown是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Markdown是什么？&quot;&gt;&lt;/a&gt;1. Markdown&lt;em&gt;是什么&lt;/em&gt;？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt;是一种轻量级&lt;strong&gt;标记语言&lt;/strong&gt;，它以纯文本形式(&lt;em&gt;易读、易写、易更改&lt;/em&gt;)编写文档，并最终以HTML格式发布。&lt;br&gt;&lt;strong&gt;Markdown&lt;/strong&gt;也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。    &lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
